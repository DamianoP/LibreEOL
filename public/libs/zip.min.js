!function (t, e) {
    "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).zip = {})
}(this, (function (t) {
    "use strict";
    const e = {
        chunkSize: 524288,
        maxWorkers: "undefined" != typeof navigator && navigator.hardwareConcurrency || 2,
        terminateWorkerTimeout: 5e3,
        useWebWorkers: !0,
        workerScripts: void 0
    }, n = Object.assign({}, e);

    function i() {
        return n
    }

    function r(t) {
        if (void 0 !== t.baseURL && (n.baseURL = t.baseURL), void 0 !== t.chunkSize && (n.chunkSize = t.chunkSize), void 0 !== t.maxWorkers && (n.maxWorkers = t.maxWorkers), void 0 !== t.terminateWorkerTimeout && (n.terminateWorkerTimeout = t.terminateWorkerTimeout), void 0 !== t.useWebWorkers && (n.useWebWorkers = t.useWebWorkers), void 0 !== t.Deflate && (n.Deflate = t.Deflate), void 0 !== t.Inflate && (n.Inflate = t.Inflate), void 0 !== t.workerScripts) {
            if (t.workerScripts.deflate) {
                if (!Array.isArray(t.workerScripts.deflate)) throw new Error("workerScripts.deflate must be an array");
                n.workerScripts || (n.workerScripts = {}), n.workerScripts.deflate = t.workerScripts.deflate
            }
            if (t.workerScripts.inflate) {
                if (!Array.isArray(t.workerScripts.inflate)) throw new Error("workerScripts.inflate must be an array");
                n.workerScripts || (n.workerScripts = {}), n.workerScripts.inflate = t.workerScripts.inflate
            }
        }
    }

    function a(t, e, n) {
        return class {
            constructor(i) {
                const r = this;
                r.codec = new t(Object.assign({}, e, i)), n(r.codec, (t => {
                    if (r.pendingData) {
                        const e = r.pendingData;
                        r.pendingData = new Uint8Array(e.length + t.length), r.pendingData.set(e, 0), r.pendingData.set(t, e.length)
                    } else r.pendingData = new Uint8Array(t)
                }))
            }

            async append(t) {
                return this.codec.push(t), i(this)
            }

            async flush() {
                return this.codec.push(new Uint8Array(0), !0), i(this)
            }
        };

        function i(t) {
            if (t.pendingData) {
                const e = t.pendingData;
                return t.pendingData = null, e
            }
            return new Uint8Array(0)
        }
    }

    const s = [];
    for (let t = 0; t < 256; t++) {
        let e = t;
        for (let t = 0; t < 8; t++) 1 & e ? e = e >>> 1 ^ 3988292384 : e >>>= 1;
        s[t] = e
    }

    class o {
        constructor(t) {
            this.crc = t || -1
        }

        append(t) {
            let e = 0 | this.crc;
            for (let n = 0, i = 0 | t.length; n < i; n++) e = e >>> 8 ^ s[255 & (e ^ t[n])];
            this.crc = e
        }

        get() {
            return ~this.crc
        }
    }

    function l(t) {
        if ("undefined" == typeof TextEncoder) {
            t = unescape(encodeURIComponent(t));
            const e = new Uint8Array(t.length);
            for (let n = 0; n < e.length; n++) e[n] = t.charCodeAt(n);
            return e
        }
        return (new TextEncoder).encode(t)
    }

    const c = {
        concat(t, e) {
            if (0 === t.length || 0 === e.length) return t.concat(e);
            const n = t[t.length - 1], i = c.getPartial(n);
            return 32 === i ? t.concat(e) : c._shiftRight(e, i, 0 | n, t.slice(0, t.length - 1))
        },
        bitLength(t) {
            const e = t.length;
            if (0 === e) return 0;
            const n = t[e - 1];
            return 32 * (e - 1) + c.getPartial(n)
        },
        clamp(t, e) {
            if (32 * t.length < e) return t;
            const n = (t = t.slice(0, Math.ceil(e / 32))).length;
            return e &= 31, n > 0 && e && (t[n - 1] = c.partial(e, t[n - 1] & 2147483648 >> e - 1, 1)), t
        },
        partial: (t, e, n) => 32 === t ? e : (n ? 0 | e : e << 32 - t) + 1099511627776 * t,
        getPartial: t => Math.round(t / 1099511627776) || 32,
        _shiftRight(t, e, n, i) {
            for (void 0 === i && (i = []); e >= 32; e -= 32) i.push(n), n = 0;
            if (0 === e) return i.concat(t);
            for (let r = 0; r < t.length; r++) i.push(n | t[r] >>> e), n = t[r] << 32 - e;
            const r = t.length ? t[t.length - 1] : 0, a = c.getPartial(r);
            return i.push(c.partial(e + a & 31, e + a > 32 ? n : i.pop(), 1)), i
        }
    }, d = {
        bytes: {
            fromBits(t) {
                const e = c.bitLength(t) / 8, n = new Uint8Array(e);
                let i;
                for (let r = 0; r < e; r++) 0 == (3 & r) && (i = t[r / 4]), n[r] = i >>> 24, i <<= 8;
                return n
            }, toBits(t) {
                const e = [];
                let n, i = 0;
                for (n = 0; n < t.length; n++) i = i << 8 | t[n], 3 == (3 & n) && (e.push(i), i = 0);
                return 3 & n && e.push(c.partial(8 * (3 & n), i)), e
            }
        }
    }, u = {
        sha1: function (t) {
            t ? (this._h = t._h.slice(0), this._buffer = t._buffer.slice(0), this._length = t._length) : this.reset()
        }
    };
    u.sha1.prototype = {
        blockSize: 512,
        reset: function () {
            const t = this;
            return t._h = this._init.slice(0), t._buffer = [], t._length = 0, t
        },
        update: function (t) {
            const e = this;
            "string" == typeof t && (t = d.utf8String.toBits(t));
            const n = e._buffer = c.concat(e._buffer, t), i = e._length, r = e._length = i + c.bitLength(t);
            if (r > 9007199254740991) throw new Error("Cannot hash more than 2^53 - 1 bits");
            const a = new Uint32Array(n);
            let s = 0;
            for (let t = e.blockSize + i - (e.blockSize + i & e.blockSize - 1); t <= r; t += e.blockSize) e._block(a.subarray(16 * s, 16 * (s + 1))), s += 1;
            return n.splice(0, 16 * s), e
        },
        finalize: function () {
            const t = this;
            let e = t._buffer;
            const n = t._h;
            e = c.concat(e, [c.partial(1, 1)]);
            for (let t = e.length + 2; 15 & t; t++) e.push(0);
            for (e.push(Math.floor(t._length / 4294967296)), e.push(0 | t._length); e.length;) t._block(e.splice(0, 16));
            return t.reset(), n
        },
        _init: [1732584193, 4023233417, 2562383102, 271733878, 3285377520],
        _key: [1518500249, 1859775393, 2400959708, 3395469782],
        _f: function (t, e, n, i) {
            return t <= 19 ? e & n | ~e & i : t <= 39 ? e ^ n ^ i : t <= 59 ? e & n | e & i | n & i : t <= 79 ? e ^ n ^ i : void 0
        },
        _S: function (t, e) {
            return e << t | e >>> 32 - t
        },
        _block: function (t) {
            const e = this, n = e._h, i = Array(80);
            for (let e = 0; e < 16; e++) i[e] = t[e];
            let r = n[0], a = n[1], s = n[2], o = n[3], l = n[4];
            for (let t = 0; t <= 79; t++) {
                t >= 16 && (i[t] = e._S(1, i[t - 3] ^ i[t - 8] ^ i[t - 14] ^ i[t - 16]));
                const n = e._S(5, r) + e._f(t, a, s, o) + l + i[t] + e._key[Math.floor(t / 20)] | 0;
                l = o, o = s, s = e._S(30, a), a = r, r = n
            }
            n[0] = n[0] + r | 0, n[1] = n[1] + a | 0, n[2] = n[2] + s | 0, n[3] = n[3] + o | 0, n[4] = n[4] + l | 0
        }
    };
    const f = {
            aes: class {
                constructor(t) {
                    const e = this;
                    e._tables = [[[], [], [], [], []], [[], [], [], [], []]], e._tables[0][0][0] || e._precompute();
                    const n = e._tables[0][4], i = e._tables[1], r = t.length;
                    let a, s, o, l = 1;
                    if (4 !== r && 6 !== r && 8 !== r) throw new Error("invalid aes key size");
                    for (e._key = [s = t.slice(0), o = []], a = r; a < 4 * r + 28; a++) {
                        let t = s[a - 1];
                        (a % r == 0 || 8 === r && a % r == 4) && (t = n[t >>> 24] << 24 ^ n[t >> 16 & 255] << 16 ^ n[t >> 8 & 255] << 8 ^ n[255 & t], a % r == 0 && (t = t << 8 ^ t >>> 24 ^ l << 24, l = l << 1 ^ 283 * (l >> 7))), s[a] = s[a - r] ^ t
                    }
                    for (let t = 0; a; t++, a--) {
                        const e = s[3 & t ? a : a - 4];
                        o[t] = a <= 4 || t < 4 ? e : i[0][n[e >>> 24]] ^ i[1][n[e >> 16 & 255]] ^ i[2][n[e >> 8 & 255]] ^ i[3][n[255 & e]]
                    }
                }

                encrypt(t) {
                    return this._crypt(t, 0)
                }

                decrypt(t) {
                    return this._crypt(t, 1)
                }

                _precompute() {
                    const t = this._tables[0], e = this._tables[1], n = t[4], i = e[4], r = [], a = [];
                    let s, o, l, c;
                    for (let t = 0; t < 256; t++) a[(r[t] = t << 1 ^ 283 * (t >> 7)) ^ t] = t;
                    for (let d = s = 0; !n[d]; d ^= o || 1, s = a[s] || 1) {
                        let a = s ^ s << 1 ^ s << 2 ^ s << 3 ^ s << 4;
                        a = a >> 8 ^ 255 & a ^ 99, n[d] = a, i[a] = d, c = r[l = r[o = r[d]]];
                        let u = 16843009 * c ^ 65537 * l ^ 257 * o ^ 16843008 * d, f = 257 * r[a] ^ 16843008 * a;
                        for (let n = 0; n < 4; n++) t[n][d] = f = f << 24 ^ f >>> 8, e[n][a] = u = u << 24 ^ u >>> 8
                    }
                    for (let n = 0; n < 5; n++) t[n] = t[n].slice(0), e[n] = e[n].slice(0)
                }

                _crypt(t, e) {
                    if (4 !== t.length) throw new Error("invalid aes block size");
                    const n = this._key[e], i = n.length / 4 - 2, r = [0, 0, 0, 0], a = this._tables[e], s = a[0], o = a[1],
                        l = a[2], c = a[3], d = a[4];
                    let u, f, h, p = t[0] ^ n[0], w = t[e ? 3 : 1] ^ n[1], _ = t[2] ^ n[2], g = t[e ? 1 : 3] ^ n[3], y = 4;
                    for (let t = 0; t < i; t++) u = s[p >>> 24] ^ o[w >> 16 & 255] ^ l[_ >> 8 & 255] ^ c[255 & g] ^ n[y], f = s[w >>> 24] ^ o[_ >> 16 & 255] ^ l[g >> 8 & 255] ^ c[255 & p] ^ n[y + 1], h = s[_ >>> 24] ^ o[g >> 16 & 255] ^ l[p >> 8 & 255] ^ c[255 & w] ^ n[y + 2], g = s[g >>> 24] ^ o[p >> 16 & 255] ^ l[w >> 8 & 255] ^ c[255 & _] ^ n[y + 3], y += 4, p = u, w = f, _ = h;
                    for (let t = 0; t < 4; t++) r[e ? 3 & -t : t] = d[p >>> 24] << 24 ^ d[w >> 16 & 255] << 16 ^ d[_ >> 8 & 255] << 8 ^ d[255 & g] ^ n[y++], u = p, p = w, w = _, _ = g, g = u;
                    return r
                }
            }
        }, h = {
            ctrGladman: class {
                constructor(t, e) {
                    this._prf = t, this._initIv = e, this._iv = e
                }

                reset() {
                    this._iv = this._initIv
                }

                update(t) {
                    return this.calculate(this._prf, t, this._iv)
                }

                incWord(t) {
                    if (255 == (t >> 24 & 255)) {
                        let e = t >> 16 & 255, n = t >> 8 & 255, i = 255 & t;
                        255 === e ? (e = 0, 255 === n ? (n = 0, 255 === i ? i = 0 : ++i) : ++n) : ++e, t = 0, t += e << 16, t += n << 8, t += i
                    } else t += 1 << 24;
                    return t
                }

                incCounter(t) {
                    0 === (t[0] = this.incWord(t[0])) && (t[1] = this.incWord(t[1]))
                }

                calculate(t, e, n) {
                    let i;
                    if (!(i = e.length)) return [];
                    const r = c.bitLength(e);
                    for (let r = 0; r < i; r += 4) {
                        this.incCounter(n);
                        const i = t.encrypt(n);
                        e[r] ^= i[0], e[r + 1] ^= i[1], e[r + 2] ^= i[2], e[r + 3] ^= i[3]
                    }
                    return c.clamp(e, r)
                }
            }
        }, p = {
            hmacSha1: class {
                constructor(t) {
                    const e = this, n = e._hash = u.sha1, i = [[], []], r = n.prototype.blockSize / 32;
                    e._baseHash = [new n, new n], t.length > r && (t = n.hash(t));
                    for (let e = 0; e < r; e++) i[0][e] = 909522486 ^ t[e], i[1][e] = 1549556828 ^ t[e];
                    e._baseHash[0].update(i[0]), e._baseHash[1].update(i[1]), e._resultHash = new n(e._baseHash[0])
                }

                reset() {
                    const t = this;
                    t._resultHash = new t._hash(t._baseHash[0]), t._updated = !1
                }

                update(t) {
                    this._updated = !0, this._resultHash.update(t)
                }

                digest() {
                    const t = this, e = t._resultHash.finalize(), n = new t._hash(t._baseHash[1]).update(e).finalize();
                    return t.reset(), n
                }
            }
        }, w = "Invalid pasword", _ = 16, g = {name: "PBKDF2"}, y = Object.assign({hash: {name: "HMAC"}}, g),
        b = Object.assign({iterations: 1e3, hash: {name: "SHA-1"}}, g), m = ["deriveBits"], x = [8, 12, 16],
        k = [16, 24, 32], v = 10, A = [0, 0, 0, 0], U = d.bytes, E = f.aes, z = h.ctrGladman, S = p.hmacSha1;

    class R {
        constructor(t, e, n) {
            Object.assign(this, {password: t, signed: e, strength: n - 1, pendingInput: new Uint8Array(0)})
        }

        async append(t) {
            const e = this;
            if (e.password) {
                const n = B(t, 0, x[e.strength] + 2);
                await async function (t, e, n) {
                    await F(t, n, B(e, 0, x[t.strength]));
                    const i = B(e, x[t.strength]), r = t.keys.passwordVerification;
                    if (r[0] != i[0] || r[1] != i[1]) throw new Error(w)
                }(e, n, e.password), e.password = null, e.aesCtrGladman = new z(new E(e.keys.key), Array.from(A)), e.hmac = new S(e.keys.authentication), t = B(t, x[e.strength] + 2)
            }
            return T(e, t, new Uint8Array(t.length - v - (t.length - v) % _), 0, v, !0)
        }

        flush() {
            const t = this, e = t.pendingInput, n = B(e, 0, e.length - v), i = B(e, e.length - v);
            let r = new Uint8Array(0);
            if (n.length) {
                const e = U.toBits(n);
                t.hmac.update(e);
                const i = t.aesCtrGladman.update(e);
                r = U.fromBits(i)
            }
            let a = !0;
            if (t.signed) {
                const e = B(U.fromBits(t.hmac.digest()), 0, v);
                for (let t = 0; t < v; t++) e[t] != i[t] && (a = !1)
            }
            return {valid: a, data: r}
        }
    }

    class D {
        constructor(t, e) {
            Object.assign(this, {password: t, strength: e - 1, pendingInput: new Uint8Array(0)})
        }

        async append(t) {
            const e = this;
            let n = new Uint8Array(0);
            e.password && (n = await async function (t, e) {
                const n = crypto.getRandomValues(new Uint8Array(x[t.strength]));
                return await F(t, e, n), I(n, t.keys.passwordVerification)
            }(e, e.password), e.password = null, e.aesCtrGladman = new z(new E(e.keys.key), Array.from(A)), e.hmac = new S(e.keys.authentication));
            const i = new Uint8Array(n.length + t.length - t.length % _);
            return i.set(n, 0), T(e, t, i, n.length, 0)
        }

        flush() {
            const t = this;
            let e = new Uint8Array(0);
            if (t.pendingInput.length) {
                const n = t.aesCtrGladman.update(U.toBits(t.pendingInput));
                t.hmac.update(n), e = U.fromBits(n)
            }
            const n = B(U.fromBits(t.hmac.digest()), 0, v);
            return {data: I(e, n), signature: n}
        }
    }

    function T(t, e, n, i, r, a) {
        const s = e.length - r;
        let o;
        for (t.pendingInput.length && (e = I(t.pendingInput, e), n = function (t, e) {
            if (e && e > t.length) {
                const n = t;
                (t = new Uint8Array(e)).set(n, 0)
            }
            return t
        }(n, s - s % _)), o = 0; o <= s - _; o += _) {
            const r = U.toBits(B(e, o, o + _));
            a && t.hmac.update(r);
            const s = t.aesCtrGladman.update(r);
            a || t.hmac.update(s), n.set(U.fromBits(s), o + i)
        }
        return t.pendingInput = B(e, o), n
    }

    async function F(t, e, n) {
        const i = l(e), r = await crypto.subtle.importKey("raw", i, y, !1, m),
            a = await crypto.subtle.deriveBits(Object.assign({salt: n}, b), r, 8 * (2 * k[t.strength] + 2)),
            s = new Uint8Array(a);
        t.keys = {
            key: U.toBits(B(s, 0, k[t.strength])),
            authentication: U.toBits(B(s, k[t.strength], 2 * k[t.strength])),
            passwordVerification: B(s, 2 * k[t.strength])
        }
    }

    function I(t, e) {
        let n = t;
        return t.length + e.length && (n = new Uint8Array(t.length + e.length), n.set(t, 0), n.set(e, t.length)), n
    }

    function B(t, e, n) {
        return t.subarray(e, n)
    }

    const C = 12;

    class M {
        constructor(t, e) {
            Object.assign(this, {password: t, passwordVerification: e}), H(this, t)
        }

        append(t) {
            const e = this;
            if (e.password) {
                const n = L(e, t.subarray(0, C));
                if (e.password = null, n[11] != e.passwordVerification) throw new Error(w);
                t = t.subarray(C)
            }
            return L(e, t)
        }

        flush() {
            return {valid: !0, data: new Uint8Array(0)}
        }
    }

    class W {
        constructor(t, e) {
            Object.assign(this, {password: t, passwordVerification: e}), H(this, t)
        }

        append(t) {
            const e = this;
            let n, i;
            if (e.password) {
                e.password = null;
                const r = crypto.getRandomValues(new Uint8Array(C));
                r[11] = e.passwordVerification, n = new Uint8Array(t.length + r.length), n.set(O(e, r), 0), i = C
            } else n = new Uint8Array(t.length), i = 0;
            return n.set(O(e, t), i), n
        }

        flush() {
            return {data: new Uint8Array(0)}
        }
    }

    function L(t, e) {
        const n = new Uint8Array(e.length);
        for (let i = 0; i < e.length; i++) n[i] = N(t) ^ e[i], P(t, n[i]);
        return n
    }

    function O(t, e) {
        const n = new Uint8Array(e.length);
        for (let i = 0; i < e.length; i++) n[i] = N(t) ^ e[i], P(t, e[i]);
        return n
    }

    function H(t, e) {
        t.keys = [305419896, 591751049, 878082192], t.crcKey0 = new o(t.keys[0]), t.crcKey2 = new o(t.keys[2]);
        for (let n = 0; n < e.length; n++) P(t, e.charCodeAt(n))
    }

    function P(t, e) {
        t.crcKey0.append([e]), t.keys[0] = ~t.crcKey0.get(), t.keys[1] = V(t.keys[1] + j(t.keys[0])), t.keys[1] = V(Math.imul(t.keys[1], 134775813) + 1), t.crcKey2.append([t.keys[1] >>> 24]), t.keys[2] = ~t.crcKey2.get()
    }

    function N(t) {
        const e = 2 | t.keys[2];
        return j(Math.imul(e, 1 ^ e) >>> 8)
    }

    function j(t) {
        return 255 & t
    }

    function V(t) {
        return 4294967295 & t
    }

    const Z = "deflate", q = "inflate", G = "Invalid signature";

    class K {
        constructor(t, {
            signature: e,
            password: n,
            signed: i,
            compressed: r,
            zipCrypto: a,
            passwordVerification: s,
            encryptionStrength: l
        }, {chunkSize: c}) {
            const d = Boolean(n);
            Object.assign(this, {
                signature: e,
                encrypted: d,
                signed: i,
                compressed: r,
                inflate: r && new t({chunkSize: c}),
                crc32: i && new o,
                zipCrypto: a,
                decrypt: d && a ? new M(n, s) : new R(n, i, l)
            })
        }

        async append(t) {
            const e = this;
            return e.encrypted && t.length && (t = await e.decrypt.append(t)), e.compressed && t.length && (t = await e.inflate.append(t)), (!e.encrypted || e.zipCrypto) && e.signed && t.length && e.crc32.append(t), t
        }

        async flush() {
            const t = this;
            let e, n = new Uint8Array(0);
            if (t.encrypted) {
                const e = t.decrypt.flush();
                if (!e.valid) throw new Error(G);
                n = e.data
            }
            if ((!t.encrypted || t.zipCrypto) && t.signed) {
                const n = new DataView(new Uint8Array(4).buffer);
                if (e = t.crc32.get(), n.setUint32(0, e), t.signature != n.getUint32(0, !1)) throw new Error(G)
            }
            return t.compressed && (n = await t.inflate.append(n) || new Uint8Array(0), await t.inflate.flush()), {
                data: n,
                signature: e
            }
        }
    }

    class X {
        constructor(t, {
            encrypted: e,
            signed: n,
            compressed: i,
            level: r,
            zipCrypto: a,
            password: s,
            passwordVerification: l,
            encryptionStrength: c
        }, {chunkSize: d}) {
            Object.assign(this, {
                encrypted: e,
                signed: n,
                compressed: i,
                deflate: i && new t({level: r || 5, chunkSize: d}),
                crc32: n && new o,
                zipCrypto: a,
                encrypt: e && a ? new W(s, l) : new D(s, c)
            })
        }

        async append(t) {
            const e = this;
            let n = t;
            return e.compressed && t.length && (n = await e.deflate.append(t)), e.encrypted && n.length && (n = await e.encrypt.append(n)), (!e.encrypted || e.zipCrypto) && e.signed && t.length && e.crc32.append(t), n
        }

        async flush() {
            const t = this;
            let e, n = new Uint8Array(0);
            if (t.compressed && (n = await t.deflate.flush() || new Uint8Array(0)), t.encrypted) {
                n = await t.encrypt.append(n);
                const i = t.encrypt.flush();
                e = i.signature;
                const r = new Uint8Array(n.length + i.data.length);
                r.set(n, 0), r.set(i.data, n.length), n = r
            }
            return t.encrypted && !t.zipCrypto || !t.signed || (e = t.crc32.get()), {data: n, signature: e}
        }
    }

    const J = "init", Y = "append", $ = "flush", Q = "message";
    let tt = !0;
    var et = (t, e, n, i, r, a, s) => (Object.assign(t, {
        busy: !0,
        codecConstructor: e,
        options: Object.assign({}, n),
        scripts: s,
        terminate() {
            t.worker && !t.busy && (t.worker.terminate(), t.interface = null)
        },
        onTaskFinished() {
            t.busy = !1, r(t)
        }
    }), a ? function (t, e) {
        let n;
        const i = {type: "module"};
        if (!t.interface) {
            if (tt) try {
                t.worker = r({}, e.baseURL)
            } catch (n) {
                tt = !1, t.worker = r(i, e.baseURL)
            } else t.worker = r(i, e.baseURL);
            t.worker.addEventListener(Q, o, !1), t.interface = {
                append: t => a({type: Y, data: t}),
                flush: () => a({type: $})
            }
        }
        return t.interface;

        function r(e, n) {
            let i;
            try {
                i = new URL(t.scripts[0], n)
            } catch (e) {
                i = t.scripts[0]
            }
            return new Worker(i, e)
        }

        async function a(i) {
            if (!n) {
                const n = t.options, i = t.scripts.slice(1);
                await s({scripts: i, type: J, options: n, config: {chunkSize: e.chunkSize}})
            }
            return s(i)
        }

        function s(e) {
            const i = t.worker, r = new Promise(((t, e) => n = {resolve: t, reject: e}));
            try {
                if (e.data) try {
                    e.data = e.data.buffer, i.postMessage(e, [e.data])
                } catch (t) {
                    i.postMessage(e)
                } else i.postMessage(e)
            } catch (e) {
                n.reject(e), n = null, t.onTaskFinished()
            }
            return r
        }

        function o(e) {
            const i = e.data;
            if (n) {
                const e = i.error, r = i.type;
                if (e) {
                    const i = new Error(e.message);
                    i.stack = e.stack, n.reject(i), n = null, t.onTaskFinished()
                } else if (r == J || r == $ || r == Y) {
                    const e = i.data;
                    r == $ ? (n.resolve({
                        data: new Uint8Array(e),
                        signature: i.signature
                    }), n = null, t.onTaskFinished()) : n.resolve(e && new Uint8Array(e))
                }
            }
        }
    }(t, i) : function (t, e) {
        const n = function (t, e, n) {
            return e.codecType.startsWith(Z) ? new X(t, e, n) : e.codecType.startsWith(q) ? new K(t, e, n) : void 0
        }(t.codecConstructor, t.options, e);
        return {
            async append(e) {
                try {
                    return await n.append(e)
                } catch (e) {
                    throw t.onTaskFinished(), e
                }
            }, async flush() {
                try {
                    return await n.flush()
                } finally {
                    t.onTaskFinished()
                }
            }
        }
    }(t, i));
    let nt = [], it = [];

    function rt(t, e, n) {
        const i = !(!e.compressed && !e.signed && !e.encrypted) && (e.useWebWorkers || void 0 === e.useWebWorkers && n.useWebWorkers),
            r = i && n.workerScripts ? n.workerScripts[e.codecType] : [];
        if (nt.length < n.maxWorkers) {
            const s = {};
            return nt.push(s), et(s, t, e, n, a, i, r)
        }
        {
            const s = nt.find((t => !t.busy));
            return s ? (at(s), et(s, t, e, n, a, i, r)) : new Promise((n => it.push({
                resolve: n,
                codecConstructor: t,
                options: e,
                webWorker: i,
                scripts: r
            })))
        }

        function a(t) {
            if (it.length) {
                const [{resolve: e, codecConstructor: i, options: r, webWorker: s, scripts: o}] = it.splice(0, 1);
                e(et(t, i, r, n, a, s, o))
            } else t.worker ? (at(t), Number.isFinite(n.terminateWorkerTimeout) && n.terminateWorkerTimeout >= 0 && (t.terminateTimeout = setTimeout((() => {
                nt = nt.filter((e => e != t)), t.terminate()
            }), n.terminateWorkerTimeout))) : nt = nt.filter((e => e != t))
        }
    }

    function at(t) {
        t.terminateTimeout && (clearTimeout(t.terminateTimeout), t.terminateTimeout = null)
    }

    const st = "Abort error";

    async function ot(t, e, n, i, r, a, s) {
        const o = Math.max(a.chunkSize, 64);
        return async function a(l = 0, c = 0) {
            const d = s.signal;
            if (l < r) {
                lt(d, t);
                const u = await e.readUint8Array(l + i, Math.min(o, r - l)), f = u.length;
                lt(d, t);
                const h = await t.append(u);
                if (lt(d, t), c += await ct(n, h), s.onprogress) try {
                    s.onprogress(l + f, r)
                } catch (t) {
                }
                return a(l + o, c)
            }
            {
                const e = await t.flush();
                return c += await ct(n, e.data), {signature: e.signature, length: c}
            }
        }()
    }

    function lt(t, e) {
        if (t && t.aborted) throw e.flush(), new Error(st)
    }

    async function ct(t, e) {
        return e.length && await t.writeUint8Array(e), e.length
    }

    const dt = "HTTP error ", ut = "HTTP Range not supported", ft = "text/plain", ht = "GET", pt = "bytes";

    class wt {
        constructor() {
            this.size = 0
        }

        init() {
            this.initialized = !0
        }
    }

    class _t extends wt {
    }

    class gt extends wt {
        writeUint8Array(t) {
            this.size += t.length
        }
    }

    class yt extends _t {
        constructor(t) {
            super(), this.blob = t, this.size = t.size
        }

        async readUint8Array(t, e) {
            if (this.blob.arrayBuffer) return new Uint8Array(await this.blob.slice(t, t + e).arrayBuffer());
            {
                const n = new FileReader;
                return new Promise(((i, r) => {
                    n.onload = t => i(new Uint8Array(t.target.result)), n.onerror = () => r(n.error), n.readAsArrayBuffer(this.blob.slice(t, t + e))
                }))
            }
        }
    }

    class bt extends gt {
        constructor(t) {
            super(), this.contentType = t, this.arrayBuffers = []
        }

        async writeUint8Array(t) {
            super.writeUint8Array(t), this.arrayBuffers.push(t.buffer)
        }

        getData() {
            return this.blob || (this.blob = new Blob(this.arrayBuffers, {type: this.contentType})), this.blob
        }
    }

    class mt extends _t {
        constructor(t, e) {
            super(), this.url = t, this.preventHeadRequest = e.preventHeadRequest, this.useRangeHeader = e.useRangeHeader, this.forceRangeRequests = e.forceRangeRequests, this.options = Object.assign({}, e), delete this.options.preventHeadRequest, delete this.options.useRangeHeader, delete this.options.forceRangeRequests, delete this.options.useXHR
        }

        async init() {
            super.init(), await kt(this, Dt, Et)
        }

        async readUint8Array(t, e) {
            return vt(this, t, e, Dt, Et)
        }
    }

    class xt extends _t {
        constructor(t, e) {
            super(), this.url = t, this.preventHeadRequest = e.preventHeadRequest, this.useRangeHeader = e.useRangeHeader, this.forceRangeRequests = e.forceRangeRequests, this.options = e
        }

        async init() {
            super.init(), await kt(this, Tt, zt)
        }

        async readUint8Array(t, e) {
            return vt(this, t, e, Tt, zt)
        }
    }

    async function kt(t, e, n) {
        if (function (t) {
            if ("undefined" != typeof document) {
                const e = document.createElement("a");
                return e.href = t, "http:" == e.protocol || "https:" == e.protocol
            }
            return /^https?:\/\//i.test(t)
        }(t.url) && (t.useRangeHeader || t.forceRangeRequests)) {
            const i = await e(ht, t, At(t));
            if (!t.forceRangeRequests && i.headers.get("Accept-Ranges") != pt) throw new Error(ut);
            {
                let r;
                const a = i.headers.get("Content-Range");
                if (a) {
                    const t = a.trim().split(/\s*\/\s*/);
                    if (t.length) {
                        const e = t[1];
                        e && "*" != e && (r = Number(e))
                    }
                }
                void 0 === r ? await Rt(t, e, n) : t.size = r
            }
        } else await Rt(t, e, n)
    }

    async function vt(t, e, n, i, r) {
        if (t.useRangeHeader || t.forceRangeRequests) {
            const r = await i(ht, t, At(t, e, n));
            if (206 != r.status) throw new Error(ut);
            return new Uint8Array(await r.arrayBuffer())
        }
        return t.data || await r(t, t.options), new Uint8Array(t.data.subarray(e, e + n))
    }

    function At(t, e = 0, n = 1) {
        return Object.assign({}, Ut(t), {Range: "bytes=" + e + "-" + (e + n - 1)})
    }

    function Ut(t) {
        let e = t.options.headers;
        if (e) return Symbol.iterator in e ? Object.fromEntries(e) : e
    }

    async function Et(t) {
        await St(t, Dt)
    }

    async function zt(t) {
        await St(t, Tt)
    }

    async function St(t, e) {
        const n = await e(ht, t, Ut(t));
        t.data = new Uint8Array(await n.arrayBuffer()), t.size || (t.size = t.data.length)
    }

    async function Rt(t, e, n) {
        if (t.preventHeadRequest) await n(t, t.options); else {
            const i = (await e("HEAD", t, Ut(t))).headers.get("Content-Length");
            i ? t.size = Number(i) : await n(t, t.options)
        }
    }

    async function Dt(t, {options: e, url: n}, i) {
        const r = await fetch(n, Object.assign({}, e, {method: t, headers: i}));
        if (r.status < 400) return r;
        throw new Error(dt + (r.statusText || r.status))
    }

    function Tt(t, {url: e}, n) {
        return new Promise(((i, r) => {
            const a = new XMLHttpRequest;
            if (a.addEventListener("load", (() => {
                if (a.status < 400) {
                    const t = [];
                    a.getAllResponseHeaders().trim().split(/[\r\n]+/).forEach((e => {
                        const n = e.trim().split(/\s*:\s*/);
                        n[0] = n[0].trim().replace(/^[a-z]|-[a-z]/g, (t => t.toUpperCase())), t.push(n)
                    })), i({status: a.status, arrayBuffer: () => a.response, headers: new Map(t)})
                } else r(new Error(dt + (a.statusText || a.status)))
            }), !1), a.addEventListener("error", (t => r(t.detail.error)), !1), a.open(t, e), n) for (const t of Object.entries(n)) a.setRequestHeader(t[0], t[1]);
            a.responseType = "arraybuffer", a.send()
        }))
    }

    class Ft extends _t {
        constructor(t, e = {}) {
            super(), this.url = t, e.useXHR ? this.reader = new xt(t, e) : this.reader = new mt(t, e)
        }

        set size(t) {
        }

        get size() {
            return this.reader.size
        }

        async init() {
            super.init(), await this.reader.init()
        }

        async readUint8Array(t, e) {
            return this.reader.readUint8Array(t, e)
        }
    }

    const It = 4294967295, Bt = 65535, Ct = 67324752, Mt = 134695760, Wt = 33639248, Lt = 101010256, Ot = 101075792,
        Ht = 117853008, Pt = 39169, Nt = 21589, jt = 2048, Vt = "/", Zt = new Date(2107, 11, 31),
        qt = new Date(1980, 0, 1),
        Gt = "\0☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ".split("");

    async function Kt(t, e) {
        if (e && "cp437" == e.trim().toLowerCase()) return (t => {
            let e = "";
            for (let n = 0; n < t.length; n++) e += Gt[t[n]];
            return e
        })(t);
        if ("undefined" == typeof TextDecoder) {
            const e = new FileReader;
            return new Promise(((n, i) => {
                e.onload = t => n(t.target.result), e.onerror = () => i(e.error), e.readAsText(new Blob([t]))
            }))
        }
        return new TextDecoder(e).decode(t)
    }

    const Xt = ["filename", "rawFilename", "directory", "encrypted", "compressedSize", "uncompressedSize", "lastModDate", "rawLastModDate", "comment", "rawComment", "signature", "extraField", "rawExtraField", "bitFlag", "extraFieldZip64", "extraFieldUnicodePath", "extraFieldUnicodeComment", "extraFieldAES", "filenameUTF8", "commentUTF8", "offset", "zip64", "compressionMethod", "extraFieldNTFS", "lastAccessDate", "creationDate", "extraFieldExtendedTimestamp", "version", "versionMadeBy", "msDosCompatible", "internalFileAttribute", "externalFileAttribute"];

    class Jt {
        constructor(t) {
            Xt.forEach((e => this[e] = t[e]))
        }
    }

    const Yt = "File format is not recognized", $t = "End of central directory not found",
        Qt = "End of Zip64 central directory not found", te = "End of Zip64 central directory locator not found",
        ee = "Central directory header not found", ne = "Local file header not found",
        ie = "Zip64 extra field not found", re = "File contains encrypted entry",
        ae = "Encryption method not supported", se = "Compression method not supported", oe = "utf-8", le = "cp437",
        ce = ["uncompressedSize", "compressedSize", "offset"];

    class de {
        constructor(t, e, n) {
            Object.assign(this, {reader: t, config: e, options: n})
        }

        async getData(t, e, n = {}) {
            const i = this, {
                reader: r,
                offset: a,
                extraFieldAES: s,
                compressionMethod: o,
                config: l,
                bitFlag: c,
                signature: d,
                rawLastModDate: u,
                compressedSize: f
            } = i, h = i.localDirectory = {};
            r.initialized || await r.init();
            let p = await ke(r, a, 30);
            const w = xe(p);
            let _ = pe(i, n, "password");
            if (_ = _ && _.length && _, s && 99 != s.originalCompressionMethod) throw new Error(se);
            if (0 != o && 8 != o) throw new Error(se);
            if (be(w, 0) != Ct) throw new Error(ne);
            ue(h, w, 4), p = await ke(r, a, 30 + h.filenameLength + h.extraFieldLength), h.rawExtraField = p.subarray(30 + h.filenameLength), await fe(i, h, w, 4), e.lastAccessDate = h.lastAccessDate, e.creationDate = h.creationDate;
            const g = i.encrypted && h.encrypted, y = g && !s;
            if (g) {
                if (!y && void 0 === s.strength) throw new Error(ae);
                if (!_) throw new Error(re)
            }
            const b = await rt(l.Inflate, {
                codecType: q,
                password: _,
                zipCrypto: y,
                encryptionStrength: s && s.strength,
                signed: pe(i, n, "checkSignature"),
                passwordVerification: y && (c.dataDescriptor ? u >>> 8 & 255 : d >>> 24 & 255),
                signature: d,
                compressed: 0 != o,
                encrypted: g,
                useWebWorkers: pe(i, n, "useWebWorkers")
            }, l);
            t.initialized || await t.init();
            const m = pe(i, n, "signal"), x = a + 30 + h.filenameLength + h.extraFieldLength;
            return await ot(b, r, t, x, f, l, {onprogress: n.onprogress, signal: m}), t.getData()
        }
    }

    function ue(t, e, n) {
        const i = t.rawBitFlag = ye(e, n + 2), r = 1 == (1 & i), a = be(e, n + 6);
        Object.assign(t, {
            encrypted: r,
            version: ye(e, n),
            bitFlag: {level: (6 & i) >> 1, dataDescriptor: 8 == (8 & i), languageEncodingFlag: (i & jt) == jt},
            rawLastModDate: a,
            lastModDate: we(a),
            filenameLength: ye(e, n + 22),
            extraFieldLength: ye(e, n + 24)
        })
    }

    async function fe(t, e, n, i) {
        const r = e.rawExtraField, a = e.extraField = new Map, s = xe(new Uint8Array(r));
        let o = 0;
        try {
            for (; o < r.length;) {
                const t = ye(s, o), e = ye(s, o + 2);
                a.set(t, {type: t, data: r.slice(o + 4, o + 4 + e)}), o += 4 + e
            }
        } catch (t) {
        }
        const l = ye(n, i + 4);
        e.signature = be(n, i + 10), e.uncompressedSize = be(n, i + 18), e.compressedSize = be(n, i + 14);
        const c = a.get(1);
        c && (!function (t, e) {
            e.zip64 = !0;
            const n = xe(t.data);
            t.values = [];
            for (let e = 0; e < Math.floor(t.data.length / 8); e++) t.values.push(me(n, 0 + 8 * e));
            const i = ce.filter((t => e[t] == It));
            for (let e = 0; e < i.length; e++) t[i[e]] = t.values[e];
            ce.forEach((n => {
                if (e[n] == It) {
                    if (void 0 === t[n]) throw new Error(ie);
                    e[n] = t[n]
                }
            }))
        }(c, e), e.extraFieldZip64 = c);
        const d = a.get(28789);
        d && (await he(d, "filename", "rawFilename", e, t), e.extraFieldUnicodePath = d);
        const u = a.get(25461);
        u && (await he(u, "comment", "rawComment", e, t), e.extraFieldUnicodeComment = u);
        const f = a.get(39169);
        f ? (!function (t, e, n) {
            const i = xe(t.data);
            t.vendorVersion = ge(i, 0), t.vendorId = ge(i, 2);
            const r = ge(i, 4);
            t.strength = r, t.originalCompressionMethod = n, e.compressionMethod = t.compressionMethod = ye(i, 5)
        }(f, e, l), e.extraFieldAES = f) : e.compressionMethod = l;
        const h = a.get(10);
        h && (!function (t, e) {
            const n = xe(t.data);
            let i, r = 4;
            try {
                for (; r < t.data.length && !i;) {
                    const e = ye(n, r), a = ye(n, r + 2);
                    1 == e && (i = t.data.slice(r + 4, r + 4 + a)), r += 4 + a
                }
            } catch (t) {
            }
            try {
                if (i && 24 == i.length) {
                    const n = xe(i), r = n.getBigUint64(0, !0), a = n.getBigUint64(8, !0), s = n.getBigUint64(16, !0);
                    Object.assign(t, {rawLastModDate: r, rawLastAccessDate: a, rawCreationDate: s});
                    const o = _e(r), l = _e(a), c = {lastModDate: o, lastAccessDate: l, creationDate: _e(s)};
                    Object.assign(t, c), Object.assign(e, c)
                }
            } catch (t) {
            }
        }(h, e), e.extraFieldNTFS = h);
        const p = a.get(Nt);
        p && (!function (t, e) {
            const n = xe(t.data), i = ge(n, 0), r = [], a = [];
            1 == (1 & i) && (r.push("lastModDate"), a.push("rawLastModDate"));
            2 == (2 & i) && (r.push("lastAccessDate"), a.push("rawLastAccessDate"));
            4 == (4 & i) && (r.push("creationDate"), a.push("rawCreationDate"));
            let s = 1;
            r.forEach(((i, r) => {
                if (t.data.length >= s + 4) {
                    const o = be(n, s);
                    e[i] = t[i] = new Date(1e3 * o);
                    const l = a[r];
                    t[l] = o
                }
                s += 4
            }))
        }(p, e), e.extraFieldExtendedTimestamp = p)
    }

    async function he(t, e, n, i, r) {
        const a = xe(t.data);
        t.version = ge(a, 0), t.signature = be(a, 1);
        const s = new o;
        s.append(r[n]);
        const l = xe(new Uint8Array(4));
        l.setUint32(0, s.get(), !0), t[e] = await Kt(t.data.subarray(5)), t.valid = !r.bitFlag.languageEncodingFlag && t.signature == be(l, 0), t.valid && (i[e] = t[e], i[e + "UTF8"] = !0)
    }

    function pe(t, e, n) {
        return void 0 === e[n] ? t.options[n] : e[n]
    }

    function we(t) {
        const e = (4294901760 & t) >> 16, n = 65535 & t;
        try {
            return new Date(1980 + ((65024 & e) >> 9), ((480 & e) >> 5) - 1, 31 & e, (63488 & n) >> 11, (2016 & n) >> 5, 2 * (31 & n), 0)
        } catch (t) {
        }
    }

    function _e(t) {
        return new Date(Number(t / BigInt(1e4) - BigInt(116444736e5)))
    }

    function ge(t, e) {
        return t.getUint8(e)
    }

    function ye(t, e) {
        return t.getUint16(e, !0)
    }

    function be(t, e) {
        return t.getUint32(e, !0)
    }

    function me(t, e) {
        return Number(t.getBigUint64(e, !0))
    }

    function xe(t) {
        return new DataView(t.buffer)
    }

    function ke(t, e, n) {
        return t.readUint8Array(e, n)
    }

    const ve = "File already exists", Ae = "Zip file comment exceeds 64KB", Ue = "File entry comment exceeds 64KB",
        Ee = "File entry name exceeds 64KB", ze = "Version exceeds 65535", Se = "The strength must equal 1, 2, or 3",
        Re = "Extra field type exceeds 65535", De = "Extra field data exceeds 64KB", Te = "Zip64 is not supported",
        Fe = new Uint8Array([7, 0, 2, 0, 65, 69, 3, 0, 0]);
    let Ie, Be = 0;

    function Ce(t, e, n) {
        if (t.arrayBuffer) return e || n ? t.slice(e, n).arrayBuffer() : t.arrayBuffer();
        {
            const i = new FileReader;
            return new Promise(((r, a) => {
                i.onload = t => r(t.target.result), i.onerror = () => a(i.error), i.readAsArrayBuffer(e || n ? t.slice(e, n) : t)
            }))
        }
    }

    function Me(t) {
        if (t) return (BigInt(t.getTime()) + BigInt(116444736e5)) * BigInt(1e4)
    }

    function We(t, e, n) {
        return void 0 === e[n] ? t.options[n] : e[n]
    }

    function Le(t, e, n) {
        t.setUint8(e, n)
    }

    function Oe(t, e, n) {
        t.setUint16(e, n, !0)
    }

    function He(t, e, n) {
        t.setUint32(e, n, !0)
    }

    function Pe(t, e, n) {
        t.setBigUint64(e, n, !0)
    }

    function Ne(t, e, n) {
        t.set(e, n)
    }

    function je(t) {
        return new DataView(t.buffer)
    }

    try {
        Ie = "undefined" == typeof document && "undefined" == typeof location ? new (require("url").URL)("file:" + __filename).href : "undefined" == typeof document ? location.href : document.currentScript && document.currentScript.src || new URL("zip.min.js", document.baseURI).href
    } catch (t) {
    }
    r({baseURL: Ie}), (t => {
        if ("function" == typeof URL.createObjectURL) {
            const e = '\n\t\t\t\n\nconst t=[];for(let e=0;e<256;e++){let n=e;for(let t=0;t<8;t++)1&n?n=n>>>1^3988292384:n>>>=1;t[e]=n;}class e{constructor(t){this.crc=t||-1;}append(e){let n=0|this.crc;for(let i=0,a=0|e.length;i<a;i++)n=n>>>8^t[255&(n^e[i])];this.crc=n;}get(){return ~this.crc}}const n={concat(t,e){if(0===t.length||0===e.length)return t.concat(e);const i=t[t.length-1],a=n.getPartial(i);return 32===a?t.concat(e):n._shiftRight(e,a,0|i,t.slice(0,t.length-1))},bitLength(t){const e=t.length;if(0===e)return 0;const i=t[e-1];return 32*(e-1)+n.getPartial(i)},clamp(t,e){if(32*t.length<e)return t;const i=(t=t.slice(0,Math.ceil(e/32))).length;return e&=31,i>0&&e&&(t[i-1]=n.partial(e,t[i-1]&2147483648>>e-1,1)),t},partial:(t,e,n)=>32===t?e:(n?0|e:e<<32-t)+1099511627776*t,getPartial:t=>Math.round(t/1099511627776)||32,_shiftRight(t,e,i,a){for(void 0===a&&(a=[]);e>=32;e-=32)a.push(i),i=0;if(0===e)return a.concat(t);for(let n=0;n<t.length;n++)a.push(i|t[n]>>>e),i=t[n]<<32-e;const r=t.length?t[t.length-1]:0,s=n.getPartial(r);return a.push(n.partial(e+s&31,e+s>32?i:a.pop(),1)),a}},i={bytes:{fromBits(t){const e=n.bitLength(t)/8,i=new Uint8Array(e);let a;for(let n=0;n<e;n++)0==(3&n)&&(a=t[n/4]),i[n]=a>>>24,a<<=8;return i},toBits(t){const e=[];let i,a=0;for(i=0;i<t.length;i++)a=a<<8|t[i],3==(3&i)&&(e.push(a),a=0);return 3&i&&e.push(n.partial(8*(3&i),a)),e}}},a={sha1:function(t){t?(this._h=t._h.slice(0),this._buffer=t._buffer.slice(0),this._length=t._length):this.reset();}};a.sha1.prototype={blockSize:512,reset:function(){const t=this;return t._h=this._init.slice(0),t._buffer=[],t._length=0,t},update:function(t){const e=this;"string"==typeof t&&(t=i.utf8String.toBits(t));const a=e._buffer=n.concat(e._buffer,t),r=e._length,s=e._length=r+n.bitLength(t);if(s>9007199254740991)throw new Error("Cannot hash more than 2^53 - 1 bits");const l=new Uint32Array(a);let o=0;for(let t=e.blockSize+r-(e.blockSize+r&e.blockSize-1);t<=s;t+=e.blockSize)e._block(l.subarray(16*o,16*(o+1))),o+=1;return a.splice(0,16*o),e},finalize:function(){const t=this;let e=t._buffer;const i=t._h;e=n.concat(e,[n.partial(1,1)]);for(let t=e.length+2;15&t;t++)e.push(0);for(e.push(Math.floor(t._length/4294967296)),e.push(0|t._length);e.length;)t._block(e.splice(0,16));return t.reset(),i},_init:[1732584193,4023233417,2562383102,271733878,3285377520],_key:[1518500249,1859775393,2400959708,3395469782],_f:function(t,e,n,i){return t<=19?e&n|~e&i:t<=39?e^n^i:t<=59?e&n|e&i|n&i:t<=79?e^n^i:void 0},_S:function(t,e){return e<<t|e>>>32-t},_block:function(t){const e=this,n=e._h,i=Array(80);for(let e=0;e<16;e++)i[e]=t[e];let a=n[0],r=n[1],s=n[2],l=n[3],o=n[4];for(let t=0;t<=79;t++){t>=16&&(i[t]=e._S(1,i[t-3]^i[t-8]^i[t-14]^i[t-16]));const n=e._S(5,a)+e._f(t,r,s,l)+o+i[t]+e._key[Math.floor(t/20)]|0;o=l,l=s,s=e._S(30,r),r=a,a=n;}n[0]=n[0]+a|0,n[1]=n[1]+r|0,n[2]=n[2]+s|0,n[3]=n[3]+l|0,n[4]=n[4]+o|0;}};const r={aes:class{constructor(t){const e=this;e._tables=[[[],[],[],[],[]],[[],[],[],[],[]]],e._tables[0][0][0]||e._precompute();const n=e._tables[0][4],i=e._tables[1],a=t.length;let r,s,l,o=1;if(4!==a&&6!==a&&8!==a)throw new Error("invalid aes key size");for(e._key=[s=t.slice(0),l=[]],r=a;r<4*a+28;r++){let t=s[r-1];(r%a==0||8===a&&r%a==4)&&(t=n[t>>>24]<<24^n[t>>16&255]<<16^n[t>>8&255]<<8^n[255&t],r%a==0&&(t=t<<8^t>>>24^o<<24,o=o<<1^283*(o>>7))),s[r]=s[r-a]^t;}for(let t=0;r;t++,r--){const e=s[3&t?r:r-4];l[t]=r<=4||t<4?e:i[0][n[e>>>24]]^i[1][n[e>>16&255]]^i[2][n[e>>8&255]]^i[3][n[255&e]];}}encrypt(t){return this._crypt(t,0)}decrypt(t){return this._crypt(t,1)}_precompute(){const t=this._tables[0],e=this._tables[1],n=t[4],i=e[4],a=[],r=[];let s,l,o,_;for(let t=0;t<256;t++)r[(a[t]=t<<1^283*(t>>7))^t]=t;for(let d=s=0;!n[d];d^=l||1,s=r[s]||1){let r=s^s<<1^s<<2^s<<3^s<<4;r=r>>8^255&r^99,n[d]=r,i[r]=d,_=a[o=a[l=a[d]]];let c=16843009*_^65537*o^257*l^16843008*d,f=257*a[r]^16843008*r;for(let n=0;n<4;n++)t[n][d]=f=f<<24^f>>>8,e[n][r]=c=c<<24^c>>>8;}for(let n=0;n<5;n++)t[n]=t[n].slice(0),e[n]=e[n].slice(0);}_crypt(t,e){if(4!==t.length)throw new Error("invalid aes block size");const n=this._key[e],i=n.length/4-2,a=[0,0,0,0],r=this._tables[e],s=r[0],l=r[1],o=r[2],_=r[3],d=r[4];let c,f,u,h=t[0]^n[0],b=t[e?3:1]^n[1],w=t[2]^n[2],p=t[e?1:3]^n[3],x=4;for(let t=0;t<i;t++)c=s[h>>>24]^l[b>>16&255]^o[w>>8&255]^_[255&p]^n[x],f=s[b>>>24]^l[w>>16&255]^o[p>>8&255]^_[255&h]^n[x+1],u=s[w>>>24]^l[p>>16&255]^o[h>>8&255]^_[255&b]^n[x+2],p=s[p>>>24]^l[h>>16&255]^o[b>>8&255]^_[255&w]^n[x+3],x+=4,h=c,b=f,w=u;for(let t=0;t<4;t++)a[e?3&-t:t]=d[h>>>24]<<24^d[b>>16&255]<<16^d[w>>8&255]<<8^d[255&p]^n[x++],c=h,h=b,b=w,w=p,p=c;return a}}},s={ctrGladman:class{constructor(t,e){this._prf=t,this._initIv=e,this._iv=e;}reset(){this._iv=this._initIv;}update(t){return this.calculate(this._prf,t,this._iv)}incWord(t){if(255==(t>>24&255)){let e=t>>16&255,n=t>>8&255,i=255&t;255===e?(e=0,255===n?(n=0,255===i?i=0:++i):++n):++e,t=0,t+=e<<16,t+=n<<8,t+=i;}else t+=1<<24;return t}incCounter(t){0===(t[0]=this.incWord(t[0]))&&(t[1]=this.incWord(t[1]));}calculate(t,e,i){let a;if(!(a=e.length))return [];const r=n.bitLength(e);for(let n=0;n<a;n+=4){this.incCounter(i);const a=t.encrypt(i);e[n]^=a[0],e[n+1]^=a[1],e[n+2]^=a[2],e[n+3]^=a[3];}return n.clamp(e,r)}}},l={hmacSha1:class{constructor(t){const e=this,n=e._hash=a.sha1,i=[[],[]],r=n.prototype.blockSize/32;e._baseHash=[new n,new n],t.length>r&&(t=n.hash(t));for(let e=0;e<r;e++)i[0][e]=909522486^t[e],i[1][e]=1549556828^t[e];e._baseHash[0].update(i[0]),e._baseHash[1].update(i[1]),e._resultHash=new n(e._baseHash[0]);}reset(){const t=this;t._resultHash=new t._hash(t._baseHash[0]),t._updated=!1;}update(t){this._updated=!0,this._resultHash.update(t);}digest(){const t=this,e=t._resultHash.finalize(),n=new t._hash(t._baseHash[1]).update(e).finalize();return t.reset(),n}}},o={name:"PBKDF2"},_=Object.assign({hash:{name:"HMAC"}},o),d=Object.assign({iterations:1e3,hash:{name:"SHA-1"}},o),c=["deriveBits"],f=[8,12,16],u=[16,24,32],h=[0,0,0,0],b=i.bytes,w=r.aes,p=s.ctrGladman,x=l.hmacSha1;class g{constructor(t,e,n){Object.assign(this,{password:t,signed:e,strength:n-1,pendingInput:new Uint8Array(0)});}async append(t){const e=this;if(e.password){const n=A(t,0,f[e.strength]+2);await async function(t,e,n){await k(t,n,A(e,0,f[t.strength]));const i=A(e,f[t.strength]),a=t.keys.passwordVerification;if(a[0]!=i[0]||a[1]!=i[1])throw new Error("Invalid pasword")}(e,n,e.password),e.password=null,e.aesCtrGladman=new p(new w(e.keys.key),Array.from(h)),e.hmac=new x(e.keys.authentication),t=A(t,f[e.strength]+2);}return m(e,t,new Uint8Array(t.length-10-(t.length-10)%16),0,10,!0)}flush(){const t=this,e=t.pendingInput,n=A(e,0,e.length-10),i=A(e,e.length-10);let a=new Uint8Array(0);if(n.length){const e=b.toBits(n);t.hmac.update(e);const i=t.aesCtrGladman.update(e);a=b.fromBits(i);}let r=!0;if(t.signed){const e=A(b.fromBits(t.hmac.digest()),0,10);for(let t=0;t<10;t++)e[t]!=i[t]&&(r=!1);}return {valid:r,data:a}}}class y{constructor(t,e){Object.assign(this,{password:t,strength:e-1,pendingInput:new Uint8Array(0)});}async append(t){const e=this;let n=new Uint8Array(0);e.password&&(n=await async function(t,e){const n=crypto.getRandomValues(new Uint8Array(f[t.strength]));return await k(t,e,n),v(n,t.keys.passwordVerification)}(e,e.password),e.password=null,e.aesCtrGladman=new p(new w(e.keys.key),Array.from(h)),e.hmac=new x(e.keys.authentication));const i=new Uint8Array(n.length+t.length-t.length%16);return i.set(n,0),m(e,t,i,n.length,0)}flush(){const t=this;let e=new Uint8Array(0);if(t.pendingInput.length){const n=t.aesCtrGladman.update(b.toBits(t.pendingInput));t.hmac.update(n),e=b.fromBits(n);}const n=A(b.fromBits(t.hmac.digest()),0,10);return {data:v(e,n),signature:n}}}function m(t,e,n,i,a,r){const s=e.length-a;let l;for(t.pendingInput.length&&(e=v(t.pendingInput,e),n=function(t,e){if(e&&e>t.length){const n=t;(t=new Uint8Array(e)).set(n,0);}return t}(n,s-s%16)),l=0;l<=s-16;l+=16){const a=b.toBits(A(e,l,l+16));r&&t.hmac.update(a);const s=t.aesCtrGladman.update(a);r||t.hmac.update(s),n.set(b.fromBits(s),l+i);}return t.pendingInput=A(e,l),n}async function k(t,e,n){const i=function(t){if("undefined"==typeof TextEncoder){t=unescape(encodeURIComponent(t));const e=new Uint8Array(t.length);for(let n=0;n<e.length;n++)e[n]=t.charCodeAt(n);return e}return (new TextEncoder).encode(t)}(e),a=await crypto.subtle.importKey("raw",i,_,!1,c),r=await crypto.subtle.deriveBits(Object.assign({salt:n},d),a,8*(2*u[t.strength]+2)),s=new Uint8Array(r);t.keys={key:b.toBits(A(s,0,u[t.strength])),authentication:b.toBits(A(s,u[t.strength],2*u[t.strength])),passwordVerification:A(s,2*u[t.strength])};}function v(t,e){let n=t;return t.length+e.length&&(n=new Uint8Array(t.length+e.length),n.set(t,0),n.set(e,t.length)),n}function A(t,e,n){return t.subarray(e,n)}class U{constructor(t,e){Object.assign(this,{password:t,passwordVerification:e}),E(this,t);}append(t){const e=this;if(e.password){const n=z(e,t.subarray(0,12));if(e.password=null,n[11]!=e.passwordVerification)throw new Error("Invalid pasword");t=t.subarray(12);}return z(e,t)}flush(){return {valid:!0,data:new Uint8Array(0)}}}class S{constructor(t,e){Object.assign(this,{password:t,passwordVerification:e}),E(this,t);}append(t){const e=this;let n,i;if(e.password){e.password=null;const a=crypto.getRandomValues(new Uint8Array(12));a[11]=e.passwordVerification,n=new Uint8Array(t.length+a.length),n.set(I(e,a),0),i=12;}else n=new Uint8Array(t.length),i=0;return n.set(I(e,t),i),n}flush(){return {data:new Uint8Array(0)}}}function z(t,e){const n=new Uint8Array(e.length);for(let i=0;i<e.length;i++)n[i]=M(t)^e[i],C(t,n[i]);return n}function I(t,e){const n=new Uint8Array(e.length);for(let i=0;i<e.length;i++)n[i]=M(t)^e[i],C(t,e[i]);return n}function E(t,n){t.keys=[305419896,591751049,878082192],t.crcKey0=new e(t.keys[0]),t.crcKey2=new e(t.keys[2]);for(let e=0;e<n.length;e++)C(t,n.charCodeAt(e));}function C(t,e){t.crcKey0.append([e]),t.keys[0]=~t.crcKey0.get(),t.keys[1]=H(t.keys[1]+B(t.keys[0])),t.keys[1]=H(Math.imul(t.keys[1],134775813)+1),t.crcKey2.append([t.keys[1]>>>24]),t.keys[2]=~t.crcKey2.get();}function M(t){const e=2|t.keys[2];return B(Math.imul(e,1^e)>>>8)}function B(t){return 255&t}function H(t){return 4294967295&t}class V{constructor(t,{signature:n,password:i,signed:a,compressed:r,zipCrypto:s,passwordVerification:l,encryptionStrength:o},{chunkSize:_}){const d=Boolean(i);Object.assign(this,{signature:n,encrypted:d,signed:a,compressed:r,inflate:r&&new t({chunkSize:_}),crc32:a&&new e,zipCrypto:s,decrypt:d&&s?new U(i,l):new g(i,a,o)});}async append(t){const e=this;return e.encrypted&&t.length&&(t=await e.decrypt.append(t)),e.compressed&&t.length&&(t=await e.inflate.append(t)),(!e.encrypted||e.zipCrypto)&&e.signed&&t.length&&e.crc32.append(t),t}async flush(){const t=this;let e,n=new Uint8Array(0);if(t.encrypted){const e=t.decrypt.flush();if(!e.valid)throw new Error("Invalid signature");n=e.data;}if((!t.encrypted||t.zipCrypto)&&t.signed){const n=new DataView(new Uint8Array(4).buffer);if(e=t.crc32.get(),n.setUint32(0,e),t.signature!=n.getUint32(0,!1))throw new Error("Invalid signature")}return t.compressed&&(n=await t.inflate.append(n)||new Uint8Array(0),await t.inflate.flush()),{data:n,signature:e}}}class D{constructor(t,{encrypted:n,signed:i,compressed:a,level:r,zipCrypto:s,password:l,passwordVerification:o,encryptionStrength:_},{chunkSize:d}){Object.assign(this,{encrypted:n,signed:i,compressed:a,deflate:a&&new t({level:r||5,chunkSize:d}),crc32:i&&new e,zipCrypto:s,encrypt:n&&s?new S(l,o):new y(l,_)});}async append(t){const e=this;let n=t;return e.compressed&&t.length&&(n=await e.deflate.append(t)),e.encrypted&&n.length&&(n=await e.encrypt.append(n)),(!e.encrypted||e.zipCrypto)&&e.signed&&t.length&&e.crc32.append(t),n}async flush(){const t=this;let e,n=new Uint8Array(0);if(t.compressed&&(n=await t.deflate.flush()||new Uint8Array(0)),t.encrypted){n=await t.encrypt.append(n);const i=t.encrypt.flush();e=i.signature;const a=new Uint8Array(n.length+i.data.length);a.set(n,0),a.set(i.data,n.length),n=a;}return t.encrypted&&!t.zipCrypto||!t.signed||(e=t.crc32.get()),{data:n,signature:e}}}const j={init(t){t.scripts&&t.scripts.length&&importScripts.apply(void 0,t.scripts);const e=t.options;let n;self.initCodec&&self.initCodec(),e.codecType.startsWith("deflate")?n=self.Deflate:e.codecType.startsWith("inflate")&&(n=self.Inflate),O=function(t,e,n){return e.codecType.startsWith("deflate")?new D(t,e,n):e.codecType.startsWith("inflate")?new V(t,e,n):void 0}(n,e,t.config);},append:async t=>({data:await O.append(t.data)}),flush:()=>O.flush()};let O;addEventListener("message",(async t=>{const e=t.data,n=e.type,i=j[n];if(i)try{e.data&&(e.data=new Uint8Array(e.data));const t=await i(e)||{};if(t.type=n,t.data)try{t.data=t.data.buffer,postMessage(t,[t.data]);}catch(e){postMessage(t);}else postMessage(t);}catch(t){postMessage({type:n,error:{message:t.message,stack:t.stack}});}}));function P(t){return K(t.map((([t,e])=>new Array(t).fill(e,0,t))))}function K(t){return t.reduce(((t,e)=>t.concat(Array.isArray(e)?K(e):e)),[])}const G=[0,1,2,3].concat(...P([[2,4],[2,5],[4,6],[4,7],[8,8],[8,9],[16,10],[16,11],[32,12],[32,13],[64,14],[64,15],[2,0],[1,16],[1,17],[2,18],[2,19],[4,20],[4,21],[8,22],[8,23],[16,24],[16,25],[32,26],[32,27],[64,28],[64,29]]));function W(){const t=this;function e(t,e){let n=0;do{n|=1&t,t>>>=1,n<<=1;}while(--e>0);return n>>>1}t.build_tree=function(n){const i=t.dyn_tree,a=t.stat_desc.static_tree,r=t.stat_desc.elems;let s,l,o,_=-1;for(n.heap_len=0,n.heap_max=573,s=0;s<r;s++)0!==i[2*s]?(n.heap[++n.heap_len]=_=s,n.depth[s]=0):i[2*s+1]=0;for(;n.heap_len<2;)o=n.heap[++n.heap_len]=_<2?++_:0,i[2*o]=1,n.depth[o]=0,n.opt_len--,a&&(n.static_len-=a[2*o+1]);for(t.max_code=_,s=Math.floor(n.heap_len/2);s>=1;s--)n.pqdownheap(i,s);o=r;do{s=n.heap[1],n.heap[1]=n.heap[n.heap_len--],n.pqdownheap(i,1),l=n.heap[1],n.heap[--n.heap_max]=s,n.heap[--n.heap_max]=l,i[2*o]=i[2*s]+i[2*l],n.depth[o]=Math.max(n.depth[s],n.depth[l])+1,i[2*s+1]=i[2*l+1]=o,n.heap[1]=o++,n.pqdownheap(i,1);}while(n.heap_len>=2);n.heap[--n.heap_max]=n.heap[1],function(e){const n=t.dyn_tree,i=t.stat_desc.static_tree,a=t.stat_desc.extra_bits,r=t.stat_desc.extra_base,s=t.stat_desc.max_length;let l,o,_,d,c,f,u=0;for(d=0;d<=15;d++)e.bl_count[d]=0;for(n[2*e.heap[e.heap_max]+1]=0,l=e.heap_max+1;l<573;l++)o=e.heap[l],d=n[2*n[2*o+1]+1]+1,d>s&&(d=s,u++),n[2*o+1]=d,o>t.max_code||(e.bl_count[d]++,c=0,o>=r&&(c=a[o-r]),f=n[2*o],e.opt_len+=f*(d+c),i&&(e.static_len+=f*(i[2*o+1]+c)));if(0!==u){do{for(d=s-1;0===e.bl_count[d];)d--;e.bl_count[d]--,e.bl_count[d+1]+=2,e.bl_count[s]--,u-=2;}while(u>0);for(d=s;0!==d;d--)for(o=e.bl_count[d];0!==o;)_=e.heap[--l],_>t.max_code||(n[2*_+1]!=d&&(e.opt_len+=(d-n[2*_+1])*n[2*_],n[2*_+1]=d),o--);}}(n),function(t,n,i){const a=[];let r,s,l,o=0;for(r=1;r<=15;r++)a[r]=o=o+i[r-1]<<1;for(s=0;s<=n;s++)l=t[2*s+1],0!==l&&(t[2*s]=e(a[l]++,l));}(i,t.max_code,n.bl_count);};}function T(t,e,n,i,a){const r=this;r.static_tree=t,r.extra_bits=e,r.extra_base=n,r.elems=i,r.max_length=a;}W._length_code=[0,1,2,3,4,5,6,7].concat(...P([[2,8],[2,9],[2,10],[2,11],[4,12],[4,13],[4,14],[4,15],[8,16],[8,17],[8,18],[8,19],[16,20],[16,21],[16,22],[16,23],[32,24],[32,25],[32,26],[31,27],[1,28]])),W.base_length=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],W.base_dist=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],W.d_code=function(t){return t<256?G[t]:G[256+(t>>>7)]},W.extra_lbits=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],W.extra_dbits=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],W.extra_blbits=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],W.bl_order=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],T.static_ltree=[12,8,140,8,76,8,204,8,44,8,172,8,108,8,236,8,28,8,156,8,92,8,220,8,60,8,188,8,124,8,252,8,2,8,130,8,66,8,194,8,34,8,162,8,98,8,226,8,18,8,146,8,82,8,210,8,50,8,178,8,114,8,242,8,10,8,138,8,74,8,202,8,42,8,170,8,106,8,234,8,26,8,154,8,90,8,218,8,58,8,186,8,122,8,250,8,6,8,134,8,70,8,198,8,38,8,166,8,102,8,230,8,22,8,150,8,86,8,214,8,54,8,182,8,118,8,246,8,14,8,142,8,78,8,206,8,46,8,174,8,110,8,238,8,30,8,158,8,94,8,222,8,62,8,190,8,126,8,254,8,1,8,129,8,65,8,193,8,33,8,161,8,97,8,225,8,17,8,145,8,81,8,209,8,49,8,177,8,113,8,241,8,9,8,137,8,73,8,201,8,41,8,169,8,105,8,233,8,25,8,153,8,89,8,217,8,57,8,185,8,121,8,249,8,5,8,133,8,69,8,197,8,37,8,165,8,101,8,229,8,21,8,149,8,85,8,213,8,53,8,181,8,117,8,245,8,13,8,141,8,77,8,205,8,45,8,173,8,109,8,237,8,29,8,157,8,93,8,221,8,61,8,189,8,125,8,253,8,19,9,275,9,147,9,403,9,83,9,339,9,211,9,467,9,51,9,307,9,179,9,435,9,115,9,371,9,243,9,499,9,11,9,267,9,139,9,395,9,75,9,331,9,203,9,459,9,43,9,299,9,171,9,427,9,107,9,363,9,235,9,491,9,27,9,283,9,155,9,411,9,91,9,347,9,219,9,475,9,59,9,315,9,187,9,443,9,123,9,379,9,251,9,507,9,7,9,263,9,135,9,391,9,71,9,327,9,199,9,455,9,39,9,295,9,167,9,423,9,103,9,359,9,231,9,487,9,23,9,279,9,151,9,407,9,87,9,343,9,215,9,471,9,55,9,311,9,183,9,439,9,119,9,375,9,247,9,503,9,15,9,271,9,143,9,399,9,79,9,335,9,207,9,463,9,47,9,303,9,175,9,431,9,111,9,367,9,239,9,495,9,31,9,287,9,159,9,415,9,95,9,351,9,223,9,479,9,63,9,319,9,191,9,447,9,127,9,383,9,255,9,511,9,0,7,64,7,32,7,96,7,16,7,80,7,48,7,112,7,8,7,72,7,40,7,104,7,24,7,88,7,56,7,120,7,4,7,68,7,36,7,100,7,20,7,84,7,52,7,116,7,3,8,131,8,67,8,195,8,35,8,163,8,99,8,227,8],T.static_dtree=[0,5,16,5,8,5,24,5,4,5,20,5,12,5,28,5,2,5,18,5,10,5,26,5,6,5,22,5,14,5,30,5,1,5,17,5,9,5,25,5,5,5,21,5,13,5,29,5,3,5,19,5,11,5,27,5,7,5,23,5],T.static_l_desc=new T(T.static_ltree,W.extra_lbits,257,286,15),T.static_d_desc=new T(T.static_dtree,W.extra_dbits,0,30,15),T.static_bl_desc=new T(null,W.extra_blbits,0,19,7);function L(t,e,n,i,a){const r=this;r.good_length=t,r.max_lazy=e,r.nice_length=n,r.max_chain=i,r.func=a;}const R=[new L(0,0,0,0,0),new L(4,4,8,4,1),new L(4,5,16,8,1),new L(4,6,32,32,1),new L(4,4,16,16,2),new L(8,16,32,32,2),new L(8,16,128,128,2),new L(8,32,128,256,2),new L(32,128,258,1024,2),new L(32,258,258,4096,2)],q=["need dictionary","stream end","","","stream error","data error","","buffer error","",""];function F(t,e,n,i){const a=t[2*e],r=t[2*n];return a<r||a==r&&i[e]<=i[n]}function J(){const t=this;let e,n,i,a,r,s,l,o,_,d,c,f,u,h,b,w,p,x,g,y,m,k,v,A,U,S,z,I,E,C,M,B,H;const V=new W,D=new W,j=new W;let O,P,K,G,L,J;function N(){let e;for(e=0;e<286;e++)M[2*e]=0;for(e=0;e<30;e++)B[2*e]=0;for(e=0;e<19;e++)H[2*e]=0;M[512]=1,t.opt_len=t.static_len=0,P=K=0;}function Q(t,e){let n,i=-1,a=t[1],r=0,s=7,l=4;0===a&&(s=138,l=3),t[2*(e+1)+1]=65535;for(let o=0;o<=e;o++)n=a,a=t[2*(o+1)+1],++r<s&&n==a||(r<l?H[2*n]+=r:0!==n?(n!=i&&H[2*n]++,H[32]++):r<=10?H[34]++:H[36]++,r=0,i=n,0===a?(s=138,l=3):n==a?(s=6,l=3):(s=7,l=4));}function X(e){t.pending_buf[t.pending++]=e;}function Y(t){X(255&t),X(t>>>8&255);}function Z(t,e){let n;const i=e;J>16-i?(n=t,L|=n<<J&65535,Y(L),L=n>>>16-J,J+=i-16):(L|=t<<J&65535,J+=i);}function $(t,e){const n=2*t;Z(65535&e[n],65535&e[n+1]);}function tt(t,e){let n,i,a=-1,r=t[1],s=0,l=7,o=4;for(0===r&&(l=138,o=3),n=0;n<=e;n++)if(i=r,r=t[2*(n+1)+1],!(++s<l&&i==r)){if(s<o)do{$(i,H);}while(0!=--s);else 0!==i?(i!=a&&($(i,H),s--),$(16,H),Z(s-3,2)):s<=10?($(17,H),Z(s-3,3)):($(18,H),Z(s-11,7));s=0,a=i,0===r?(l=138,o=3):i==r?(l=6,o=3):(l=7,o=4);}}function et(){16==J?(Y(L),L=0,J=0):J>=8&&(X(255&L),L>>>=8,J-=8);}function nt(e,n){let i,a,r;if(t.dist_buf[P]=e,t.lc_buf[P]=255&n,P++,0===e?M[2*n]++:(K++,e--,M[2*(W._length_code[n]+256+1)]++,B[2*W.d_code(e)]++),0==(8191&P)&&z>2){for(i=8*P,a=m-p,r=0;r<30;r++)i+=B[2*r]*(5+W.extra_dbits[r]);if(i>>>=3,K<Math.floor(P/2)&&i<Math.floor(a/2))return !0}return P==O-1}function it(e,n){let i,a,r,s,l=0;if(0!==P)do{i=t.dist_buf[l],a=t.lc_buf[l],l++,0===i?$(a,e):(r=W._length_code[a],$(r+256+1,e),s=W.extra_lbits[r],0!==s&&(a-=W.base_length[r],Z(a,s)),i--,r=W.d_code(i),$(r,n),s=W.extra_dbits[r],0!==s&&(i-=W.base_dist[r],Z(i,s)));}while(l<P);$(256,e),G=e[513];}function at(){J>8?Y(L):J>0&&X(255&L),L=0,J=0;}function rt(e,n,i){Z(0+(i?1:0),3),function(e,n,i){at(),G=8,i&&(Y(n),Y(~n)),t.pending_buf.set(o.subarray(e,e+n),t.pending),t.pending+=n;}(e,n,!0);}function st(e,n,i){let a,r,s=0;z>0?(V.build_tree(t),D.build_tree(t),s=function(){let e;for(Q(M,V.max_code),Q(B,D.max_code),j.build_tree(t),e=18;e>=3&&0===H[2*W.bl_order[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(),a=t.opt_len+3+7>>>3,r=t.static_len+3+7>>>3,r<=a&&(a=r)):a=r=n+5,n+4<=a&&-1!=e?rt(e,n,i):r==a?(Z(2+(i?1:0),3),it(T.static_ltree,T.static_dtree)):(Z(4+(i?1:0),3),function(t,e,n){let i;for(Z(t-257,5),Z(e-1,5),Z(n-4,4),i=0;i<n;i++)Z(H[2*W.bl_order[i]+1],3);tt(M,t-1),tt(B,e-1);}(V.max_code+1,D.max_code+1,s+1),it(M,B)),N(),i&&at();}function lt(t){st(p>=0?p:-1,m-p,t),p=m,e.flush_pending();}function ot(){let t,n,i,a;do{if(a=_-v-m,0===a&&0===m&&0===v)a=r;else if(-1==a)a--;else if(m>=r+r-262){o.set(o.subarray(r,r+r),0),k-=r,m-=r,p-=r,t=u,i=t;do{n=65535&c[--i],c[i]=n>=r?n-r:0;}while(0!=--t);t=r,i=t;do{n=65535&d[--i],d[i]=n>=r?n-r:0;}while(0!=--t);a+=r;}if(0===e.avail_in)return;t=e.read_buf(o,m+v,a),v+=t,v>=3&&(f=255&o[m],f=(f<<w^255&o[m+1])&b);}while(v<262&&0!==e.avail_in)}function _t(t){let e,n,i=U,a=m,s=A;const _=m>r-262?m-(r-262):0;let c=C;const f=l,u=m+258;let h=o[a+s-1],b=o[a+s];A>=E&&(i>>=2),c>v&&(c=v);do{if(e=t,o[e+s]==b&&o[e+s-1]==h&&o[e]==o[a]&&o[++e]==o[a+1]){a+=2,e++;do{}while(o[++a]==o[++e]&&o[++a]==o[++e]&&o[++a]==o[++e]&&o[++a]==o[++e]&&o[++a]==o[++e]&&o[++a]==o[++e]&&o[++a]==o[++e]&&o[++a]==o[++e]&&a<u);if(n=258-(u-a),a=u-258,n>s){if(k=t,s=n,n>=c)break;h=o[a+s-1],b=o[a+s];}}}while((t=65535&d[t&f])>_&&0!=--i);return s<=v?s:v}function dt(e){return e.total_in=e.total_out=0,e.msg=null,t.pending=0,t.pending_out=0,n=113,a=0,V.dyn_tree=M,V.stat_desc=T.static_l_desc,D.dyn_tree=B,D.stat_desc=T.static_d_desc,j.dyn_tree=H,j.stat_desc=T.static_bl_desc,L=0,J=0,G=8,N(),function(){_=2*r,c[u-1]=0;for(let t=0;t<u-1;t++)c[t]=0;S=R[z].max_lazy,E=R[z].good_length,C=R[z].nice_length,U=R[z].max_chain,m=0,p=0,v=0,x=A=2,y=0,f=0;}(),0}t.depth=[],t.bl_count=[],t.heap=[],M=[],B=[],H=[],t.pqdownheap=function(e,n){const i=t.heap,a=i[n];let r=n<<1;for(;r<=t.heap_len&&(r<t.heap_len&&F(e,i[r+1],i[r],t.depth)&&r++,!F(e,a,i[r],t.depth));)i[n]=i[r],n=r,r<<=1;i[n]=a;},t.deflateInit=function(e,n,a,_,f,p){return _||(_=8),f||(f=8),p||(p=0),e.msg=null,-1==n&&(n=6),f<1||f>9||8!=_||a<9||a>15||n<0||n>9||p<0||p>2?-2:(e.dstate=t,s=a,r=1<<s,l=r-1,h=f+7,u=1<<h,b=u-1,w=Math.floor((h+3-1)/3),o=new Uint8Array(2*r),d=[],c=[],O=1<<f+6,t.pending_buf=new Uint8Array(4*O),i=4*O,t.dist_buf=new Uint16Array(O),t.lc_buf=new Uint8Array(O),z=n,I=p,dt(e))},t.deflateEnd=function(){return 42!=n&&113!=n&&666!=n?-2:(t.lc_buf=null,t.dist_buf=null,t.pending_buf=null,c=null,d=null,o=null,t.dstate=null,113==n?-3:0)},t.deflateParams=function(t,e,n){let i=0;return -1==e&&(e=6),e<0||e>9||n<0||n>2?-2:(R[z].func!=R[e].func&&0!==t.total_in&&(i=t.deflate(1)),z!=e&&(z=e,S=R[z].max_lazy,E=R[z].good_length,C=R[z].nice_length,U=R[z].max_chain),I=n,i)},t.deflateSetDictionary=function(t,e,i){let a,s=i,_=0;if(!e||42!=n)return -2;if(s<3)return 0;for(s>r-262&&(s=r-262,_=i-s),o.set(e.subarray(_,_+s),0),m=s,p=s,f=255&o[0],f=(f<<w^255&o[1])&b,a=0;a<=s-3;a++)f=(f<<w^255&o[a+2])&b,d[a&l]=c[f],c[f]=a;return 0},t.deflate=function(_,h){let U,E,C,M,B;if(h>4||h<0)return -2;if(!_.next_out||!_.next_in&&0!==_.avail_in||666==n&&4!=h)return _.msg=q[4],-2;if(0===_.avail_out)return _.msg=q[7],-5;var H;if(e=_,M=a,a=h,42==n&&(E=8+(s-8<<4)<<8,C=(z-1&255)>>1,C>3&&(C=3),E|=C<<6,0!==m&&(E|=32),E+=31-E%31,n=113,X((H=E)>>8&255),X(255&H)),0!==t.pending){if(e.flush_pending(),0===e.avail_out)return a=-1,0}else if(0===e.avail_in&&h<=M&&4!=h)return e.msg=q[7],-5;if(666==n&&0!==e.avail_in)return _.msg=q[7],-5;if(0!==e.avail_in||0!==v||0!=h&&666!=n){switch(B=-1,R[z].func){case 0:B=function(t){let n,a=65535;for(a>i-5&&(a=i-5);;){if(v<=1){if(ot(),0===v&&0==t)return 0;if(0===v)break}if(m+=v,v=0,n=p+a,(0===m||m>=n)&&(v=m-n,m=n,lt(!1),0===e.avail_out))return 0;if(m-p>=r-262&&(lt(!1),0===e.avail_out))return 0}return lt(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(h);break;case 1:B=function(t){let n,i=0;for(;;){if(v<262){if(ot(),v<262&&0==t)return 0;if(0===v)break}if(v>=3&&(f=(f<<w^255&o[m+2])&b,i=65535&c[f],d[m&l]=c[f],c[f]=m),0!==i&&(m-i&65535)<=r-262&&2!=I&&(x=_t(i)),x>=3)if(n=nt(m-k,x-3),v-=x,x<=S&&v>=3){x--;do{m++,f=(f<<w^255&o[m+2])&b,i=65535&c[f],d[m&l]=c[f],c[f]=m;}while(0!=--x);m++;}else m+=x,x=0,f=255&o[m],f=(f<<w^255&o[m+1])&b;else n=nt(0,255&o[m]),v--,m++;if(n&&(lt(!1),0===e.avail_out))return 0}return lt(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(h);break;case 2:B=function(t){let n,i,a=0;for(;;){if(v<262){if(ot(),v<262&&0==t)return 0;if(0===v)break}if(v>=3&&(f=(f<<w^255&o[m+2])&b,a=65535&c[f],d[m&l]=c[f],c[f]=m),A=x,g=k,x=2,0!==a&&A<S&&(m-a&65535)<=r-262&&(2!=I&&(x=_t(a)),x<=5&&(1==I||3==x&&m-k>4096)&&(x=2)),A>=3&&x<=A){i=m+v-3,n=nt(m-1-g,A-3),v-=A-1,A-=2;do{++m<=i&&(f=(f<<w^255&o[m+2])&b,a=65535&c[f],d[m&l]=c[f],c[f]=m);}while(0!=--A);if(y=0,x=2,m++,n&&(lt(!1),0===e.avail_out))return 0}else if(0!==y){if(n=nt(0,255&o[m-1]),n&&lt(!1),m++,v--,0===e.avail_out)return 0}else y=1,m++,v--;}return 0!==y&&(n=nt(0,255&o[m-1]),y=0),lt(4==t),0===e.avail_out?4==t?2:0:4==t?3:1}(h);}if(2!=B&&3!=B||(n=666),0==B||2==B)return 0===e.avail_out&&(a=-1),0;if(1==B){if(1==h)Z(2,3),$(256,T.static_ltree),et(),1+G+10-J<9&&(Z(2,3),$(256,T.static_ltree),et()),G=7;else if(rt(0,0,!1),3==h)for(U=0;U<u;U++)c[U]=0;if(e.flush_pending(),0===e.avail_out)return a=-1,0}}return 4!=h?0:1};}function N(){const t=this;t.next_in_index=0,t.next_out_index=0,t.avail_in=0,t.total_in=0,t.avail_out=0,t.total_out=0;}function Q(t){const e=new N,n=(i=t&&t.chunkSize?t.chunkSize:65536)+5*(Math.floor(i/16383)+1);var i;const a=new Uint8Array(n);let r=t?t.level:-1;void 0===r&&(r=-1),e.deflateInit(r),e.next_out=a,this.append=function(t,i){let r,s,l=0,o=0,_=0;const d=[];if(t.length){e.next_in_index=0,e.next_in=t,e.avail_in=t.length;do{if(e.next_out_index=0,e.avail_out=n,r=e.deflate(0),0!=r)throw new Error("deflating: "+e.msg);e.next_out_index&&(e.next_out_index==n?d.push(new Uint8Array(a)):d.push(a.slice(0,e.next_out_index))),_+=e.next_out_index,i&&e.next_in_index>0&&e.next_in_index!=l&&(i(e.next_in_index),l=e.next_in_index);}while(e.avail_in>0||0===e.avail_out);return d.length>1?(s=new Uint8Array(_),d.forEach((function(t){s.set(t,o),o+=t.length;}))):s=d[0]||new Uint8Array(0),s}},this.flush=function(){let t,i,r=0,s=0;const l=[];do{if(e.next_out_index=0,e.avail_out=n,t=e.deflate(4),1!=t&&0!=t)throw new Error("deflating: "+e.msg);n-e.avail_out>0&&l.push(a.slice(0,e.next_out_index)),s+=e.next_out_index;}while(e.avail_in>0||0===e.avail_out);return e.deflateEnd(),i=new Uint8Array(s),l.forEach((function(t){i.set(t,r),r+=t.length;})),i};}N.prototype={deflateInit:function(t,e){const n=this;return n.dstate=new J,e||(e=15),n.dstate.deflateInit(n,t,e)},deflate:function(t){const e=this;return e.dstate?e.dstate.deflate(e,t):-2},deflateEnd:function(){const t=this;if(!t.dstate)return -2;const e=t.dstate.deflateEnd();return t.dstate=null,e},deflateParams:function(t,e){const n=this;return n.dstate?n.dstate.deflateParams(n,t,e):-2},deflateSetDictionary:function(t,e){const n=this;return n.dstate?n.dstate.deflateSetDictionary(n,t,e):-2},read_buf:function(t,e,n){const i=this;let a=i.avail_in;return a>n&&(a=n),0===a?0:(i.avail_in-=a,t.set(i.next_in.subarray(i.next_in_index,i.next_in_index+a),e),i.next_in_index+=a,i.total_in+=a,a)},flush_pending:function(){const t=this;let e=t.dstate.pending;e>t.avail_out&&(e=t.avail_out),0!==e&&(t.next_out.set(t.dstate.pending_buf.subarray(t.dstate.pending_out,t.dstate.pending_out+e),t.next_out_index),t.next_out_index+=e,t.dstate.pending_out+=e,t.total_out+=e,t.avail_out-=e,t.dstate.pending-=e,0===t.dstate.pending&&(t.dstate.pending_out=0));}};const X=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],Y=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],Z=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],$=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],tt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],et=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],nt=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function it(){let t,e,n,i,a,r;function s(t,e,s,l,o,_,d,c,f,u,h){let b,w,p,x,g,y,m,k,v,A,U,S,z,I,E;A=0,g=s;do{n[t[e+A]]++,A++,g--;}while(0!==g);if(n[0]==s)return d[0]=-1,c[0]=0,0;for(k=c[0],y=1;y<=15&&0===n[y];y++);for(m=y,k<y&&(k=y),g=15;0!==g&&0===n[g];g--);for(p=g,k>g&&(k=g),c[0]=k,I=1<<y;y<g;y++,I<<=1)if((I-=n[y])<0)return -3;if((I-=n[g])<0)return -3;for(n[g]+=I,r[1]=y=0,A=1,z=2;0!=--g;)r[z]=y+=n[A],z++,A++;g=0,A=0;do{0!==(y=t[e+A])&&(h[r[y]++]=g),A++;}while(++g<s);for(s=r[p],r[0]=g=0,A=0,x=-1,S=-k,a[0]=0,U=0,E=0;m<=p;m++)for(b=n[m];0!=b--;){for(;m>S+k;){if(x++,S+=k,E=p-S,E=E>k?k:E,(w=1<<(y=m-S))>b+1&&(w-=b+1,z=m,y<E))for(;++y<E&&!((w<<=1)<=n[++z]);)w-=n[z];if(E=1<<y,u[0]+E>1440)return -3;a[x]=U=u[0],u[0]+=E,0!==x?(r[x]=g,i[0]=y,i[1]=k,y=g>>>S-k,i[2]=U-a[x-1]-y,f.set(i,3*(a[x-1]+y))):d[0]=U;}for(i[1]=m-S,A>=s?i[0]=192:h[A]<l?(i[0]=h[A]<256?0:96,i[2]=h[A++]):(i[0]=_[h[A]-l]+16+64,i[2]=o[h[A++]-l]),w=1<<m-S,y=g>>>S;y<E;y+=w)f.set(i,3*(U+y));for(y=1<<m-1;0!=(g&y);y>>>=1)g^=y;for(g^=y,v=(1<<S)-1;(g&v)!=r[x];)x--,S-=k,v=(1<<S)-1;}return 0!==I&&1!=p?-5:0}function l(s){let l;for(t||(t=[],e=[],n=new Int32Array(16),i=[],a=new Int32Array(15),r=new Int32Array(16)),e.length<s&&(e=[]),l=0;l<s;l++)e[l]=0;for(l=0;l<16;l++)n[l]=0;for(l=0;l<3;l++)i[l]=0;a.set(n.subarray(0,15),0),r.set(n.subarray(0,16),0);}this.inflate_trees_bits=function(n,i,a,r,o){let _;return l(19),t[0]=0,_=s(n,0,19,19,null,null,a,i,r,t,e),-3==_?o.msg="oversubscribed dynamic bit lengths tree":-5!=_&&0!==i[0]||(o.msg="incomplete dynamic bit lengths tree",_=-3),_},this.inflate_trees_dynamic=function(n,i,a,r,o,_,d,c,f){let u;return l(288),t[0]=0,u=s(a,0,n,257,$,tt,_,r,c,t,e),0!=u||0===r[0]?(-3==u?f.msg="oversubscribed literal/length tree":-4!=u&&(f.msg="incomplete literal/length tree",u=-3),u):(l(288),u=s(a,n,i,0,et,nt,d,o,c,t,e),0!=u||0===o[0]&&n>257?(-3==u?f.msg="oversubscribed distance tree":-5==u?(f.msg="incomplete distance tree",u=-3):-4!=u&&(f.msg="empty distance tree with lengths",u=-3),u):0)};}it.inflate_trees_fixed=function(t,e,n,i){return t[0]=9,e[0]=5,n[0]=Y,i[0]=Z,0};function at(){const t=this;let e,n,i,a,r=0,s=0,l=0,o=0,_=0,d=0,c=0,f=0,u=0,h=0;function b(t,e,n,i,a,r,s,l){let o,_,d,c,f,u,h,b,w,p,x,g,y,m,k,v;h=l.next_in_index,b=l.avail_in,f=s.bitb,u=s.bitk,w=s.write,p=w<s.read?s.read-w-1:s.end-w,x=X[t],g=X[e];do{for(;u<20;)b--,f|=(255&l.read_byte(h++))<<u,u+=8;if(o=f&x,_=n,d=i,v=3*(d+o),0!==(c=_[v]))for(;;){if(f>>=_[v+1],u-=_[v+1],0!=(16&c)){for(c&=15,y=_[v+2]+(f&X[c]),f>>=c,u-=c;u<15;)b--,f|=(255&l.read_byte(h++))<<u,u+=8;for(o=f&g,_=a,d=r,v=3*(d+o),c=_[v];;){if(f>>=_[v+1],u-=_[v+1],0!=(16&c)){for(c&=15;u<c;)b--,f|=(255&l.read_byte(h++))<<u,u+=8;if(m=_[v+2]+(f&X[c]),f>>=c,u-=c,p-=y,w>=m)k=w-m,w-k>0&&2>w-k?(s.window[w++]=s.window[k++],s.window[w++]=s.window[k++],y-=2):(s.window.set(s.window.subarray(k,k+2),w),w+=2,k+=2,y-=2);else {k=w-m;do{k+=s.end;}while(k<0);if(c=s.end-k,y>c){if(y-=c,w-k>0&&c>w-k)do{s.window[w++]=s.window[k++];}while(0!=--c);else s.window.set(s.window.subarray(k,k+c),w),w+=c,k+=c,c=0;k=0;}}if(w-k>0&&y>w-k)do{s.window[w++]=s.window[k++];}while(0!=--y);else s.window.set(s.window.subarray(k,k+y),w),w+=y,k+=y,y=0;break}if(0!=(64&c))return l.msg="invalid distance code",y=l.avail_in-b,y=u>>3<y?u>>3:y,b+=y,h-=y,u-=y<<3,s.bitb=f,s.bitk=u,l.avail_in=b,l.total_in+=h-l.next_in_index,l.next_in_index=h,s.write=w,-3;o+=_[v+2],o+=f&X[c],v=3*(d+o),c=_[v];}break}if(0!=(64&c))return 0!=(32&c)?(y=l.avail_in-b,y=u>>3<y?u>>3:y,b+=y,h-=y,u-=y<<3,s.bitb=f,s.bitk=u,l.avail_in=b,l.total_in+=h-l.next_in_index,l.next_in_index=h,s.write=w,1):(l.msg="invalid literal/length code",y=l.avail_in-b,y=u>>3<y?u>>3:y,b+=y,h-=y,u-=y<<3,s.bitb=f,s.bitk=u,l.avail_in=b,l.total_in+=h-l.next_in_index,l.next_in_index=h,s.write=w,-3);if(o+=_[v+2],o+=f&X[c],v=3*(d+o),0===(c=_[v])){f>>=_[v+1],u-=_[v+1],s.window[w++]=_[v+2],p--;break}}else f>>=_[v+1],u-=_[v+1],s.window[w++]=_[v+2],p--;}while(p>=258&&b>=10);return y=l.avail_in-b,y=u>>3<y?u>>3:y,b+=y,h-=y,u-=y<<3,s.bitb=f,s.bitk=u,l.avail_in=b,l.total_in+=h-l.next_in_index,l.next_in_index=h,s.write=w,0}t.init=function(t,r,s,l,o,_){e=0,c=t,f=r,i=s,u=l,a=o,h=_,n=null;},t.proc=function(t,w,p){let x,g,y,m,k,v,A,U=0,S=0,z=0;for(z=w.next_in_index,m=w.avail_in,U=t.bitb,S=t.bitk,k=t.write,v=k<t.read?t.read-k-1:t.end-k;;)switch(e){case 0:if(v>=258&&m>=10&&(t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,p=b(c,f,i,u,a,h,t,w),z=w.next_in_index,m=w.avail_in,U=t.bitb,S=t.bitk,k=t.write,v=k<t.read?t.read-k-1:t.end-k,0!=p)){e=1==p?7:9;break}l=c,n=i,s=u,e=1;case 1:for(x=l;S<x;){if(0===m)return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);p=0,m--,U|=(255&w.read_byte(z++))<<S,S+=8;}if(g=3*(s+(U&X[x])),U>>>=n[g+1],S-=n[g+1],y=n[g],0===y){o=n[g+2],e=6;break}if(0!=(16&y)){_=15&y,r=n[g+2],e=2;break}if(0==(64&y)){l=y,s=g/3+n[g+2];break}if(0!=(32&y)){e=7;break}return e=9,w.msg="invalid literal/length code",p=-3,t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);case 2:for(x=_;S<x;){if(0===m)return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);p=0,m--,U|=(255&w.read_byte(z++))<<S,S+=8;}r+=U&X[x],U>>=x,S-=x,l=f,n=a,s=h,e=3;case 3:for(x=l;S<x;){if(0===m)return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);p=0,m--,U|=(255&w.read_byte(z++))<<S,S+=8;}if(g=3*(s+(U&X[x])),U>>=n[g+1],S-=n[g+1],y=n[g],0!=(16&y)){_=15&y,d=n[g+2],e=4;break}if(0==(64&y)){l=y,s=g/3+n[g+2];break}return e=9,w.msg="invalid distance code",p=-3,t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);case 4:for(x=_;S<x;){if(0===m)return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);p=0,m--,U|=(255&w.read_byte(z++))<<S,S+=8;}d+=U&X[x],U>>=x,S-=x,e=5;case 5:for(A=k-d;A<0;)A+=t.end;for(;0!==r;){if(0===v&&(k==t.end&&0!==t.read&&(k=0,v=k<t.read?t.read-k-1:t.end-k),0===v&&(t.write=k,p=t.inflate_flush(w,p),k=t.write,v=k<t.read?t.read-k-1:t.end-k,k==t.end&&0!==t.read&&(k=0,v=k<t.read?t.read-k-1:t.end-k),0===v)))return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);t.window[k++]=t.window[A++],v--,A==t.end&&(A=0),r--;}e=0;break;case 6:if(0===v&&(k==t.end&&0!==t.read&&(k=0,v=k<t.read?t.read-k-1:t.end-k),0===v&&(t.write=k,p=t.inflate_flush(w,p),k=t.write,v=k<t.read?t.read-k-1:t.end-k,k==t.end&&0!==t.read&&(k=0,v=k<t.read?t.read-k-1:t.end-k),0===v)))return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);p=0,t.window[k++]=o,v--,e=0;break;case 7:if(S>7&&(S-=8,m++,z--),t.write=k,p=t.inflate_flush(w,p),k=t.write,v=k<t.read?t.read-k-1:t.end-k,t.read!=t.write)return t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);e=8;case 8:return p=1,t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);case 9:return p=-3,t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p);default:return p=-2,t.bitb=U,t.bitk=S,w.avail_in=m,w.total_in+=z-w.next_in_index,w.next_in_index=z,t.write=k,t.inflate_flush(w,p)}},t.free=function(){};}const rt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function st(t,e){const n=this;let i,a=0,r=0,s=0,l=0;const o=[0],_=[0],d=new at;let c=0,f=new Int32Array(4320);const u=new it;n.bitk=0,n.bitb=0,n.window=new Uint8Array(e),n.end=e,n.read=0,n.write=0,n.reset=function(t,e){e&&(e[0]=0),6==a&&d.free(t),a=0,n.bitk=0,n.bitb=0,n.read=n.write=0;},n.reset(t,null),n.inflate_flush=function(t,e){let i,a,r;return a=t.next_out_index,r=n.read,i=(r<=n.write?n.write:n.end)-r,i>t.avail_out&&(i=t.avail_out),0!==i&&-5==e&&(e=0),t.avail_out-=i,t.total_out+=i,t.next_out.set(n.window.subarray(r,r+i),a),a+=i,r+=i,r==n.end&&(r=0,n.write==n.end&&(n.write=0),i=n.write-r,i>t.avail_out&&(i=t.avail_out),0!==i&&-5==e&&(e=0),t.avail_out-=i,t.total_out+=i,t.next_out.set(n.window.subarray(r,r+i),a),a+=i,r+=i),t.next_out_index=a,n.read=r,e},n.proc=function(t,e){let h,b,w,p,x,g,y,m;for(p=t.next_in_index,x=t.avail_in,b=n.bitb,w=n.bitk,g=n.write,y=g<n.read?n.read-g-1:n.end-g;;){let k,v,A,U,S,z,I,E;switch(a){case 0:for(;w<3;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}switch(h=7&b,c=1&h,h>>>1){case 0:b>>>=3,w-=3,h=7&w,b>>>=h,w-=h,a=1;break;case 1:k=[],v=[],A=[[]],U=[[]],it.inflate_trees_fixed(k,v,A,U),d.init(k[0],v[0],A[0],0,U[0],0),b>>>=3,w-=3,a=6;break;case 2:b>>>=3,w-=3,a=3;break;case 3:return b>>>=3,w-=3,a=9,t.msg="invalid block type",e=-3,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e)}break;case 1:for(;w<32;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}if((~b>>>16&65535)!=(65535&b))return a=9,t.msg="invalid stored block lengths",e=-3,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);r=65535&b,b=w=0,a=0!==r?2:0!==c?7:0;break;case 2:if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);if(0===y&&(g==n.end&&0!==n.read&&(g=0,y=g<n.read?n.read-g-1:n.end-g),0===y&&(n.write=g,e=n.inflate_flush(t,e),g=n.write,y=g<n.read?n.read-g-1:n.end-g,g==n.end&&0!==n.read&&(g=0,y=g<n.read?n.read-g-1:n.end-g),0===y)))return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);if(e=0,h=r,h>x&&(h=x),h>y&&(h=y),n.window.set(t.read_buf(p,h),g),p+=h,x-=h,g+=h,y-=h,0!=(r-=h))break;a=0!==c?7:0;break;case 3:for(;w<14;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}if(s=h=16383&b,(31&h)>29||(h>>5&31)>29)return a=9,t.msg="too many length or distance symbols",e=-3,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);if(h=258+(31&h)+(h>>5&31),!i||i.length<h)i=[];else for(m=0;m<h;m++)i[m]=0;b>>>=14,w-=14,l=0,a=4;case 4:for(;l<4+(s>>>10);){for(;w<3;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}i[rt[l++]]=7&b,b>>>=3,w-=3;}for(;l<19;)i[rt[l++]]=0;if(o[0]=7,h=u.inflate_trees_bits(i,o,_,f,t),0!=h)return -3==(e=h)&&(i=null,a=9),n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);l=0,a=5;case 5:for(;h=s,!(l>=258+(31&h)+(h>>5&31));){let r,d;for(h=o[0];w<h;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}if(h=f[3*(_[0]+(b&X[h]))+1],d=f[3*(_[0]+(b&X[h]))+2],d<16)b>>>=h,w-=h,i[l++]=d;else {for(m=18==d?7:d-14,r=18==d?11:3;w<h+m;){if(0===x)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);e=0,x--,b|=(255&t.read_byte(p++))<<w,w+=8;}if(b>>>=h,w-=h,r+=b&X[m],b>>>=m,w-=m,m=l,h=s,m+r>258+(31&h)+(h>>5&31)||16==d&&m<1)return i=null,a=9,t.msg="invalid bit length repeat",e=-3,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);d=16==d?i[m-1]:0;do{i[m++]=d;}while(0!=--r);l=m;}}if(_[0]=-1,S=[],z=[],I=[],E=[],S[0]=9,z[0]=6,h=s,h=u.inflate_trees_dynamic(257+(31&h),1+(h>>5&31),i,S,z,I,E,f,t),0!=h)return -3==h&&(i=null,a=9),e=h,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);d.init(S[0],z[0],f,I[0],f,E[0]),a=6;case 6:if(n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,1!=(e=d.proc(n,t,e)))return n.inflate_flush(t,e);if(e=0,d.free(t),p=t.next_in_index,x=t.avail_in,b=n.bitb,w=n.bitk,g=n.write,y=g<n.read?n.read-g-1:n.end-g,0===c){a=0;break}a=7;case 7:if(n.write=g,e=n.inflate_flush(t,e),g=n.write,y=g<n.read?n.read-g-1:n.end-g,n.read!=n.write)return n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);a=8;case 8:return e=1,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);case 9:return e=-3,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e);default:return e=-2,n.bitb=b,n.bitk=w,t.avail_in=x,t.total_in+=p-t.next_in_index,t.next_in_index=p,n.write=g,n.inflate_flush(t,e)}}},n.free=function(t){n.reset(t,null),n.window=null,f=null;},n.set_dictionary=function(t,e,i){n.window.set(t.subarray(e,e+i),0),n.read=n.write=i;},n.sync_point=function(){return 1==a?1:0};}const lt=[0,0,255,255];function ot(){const t=this;function e(t){return t&&t.istate?(t.total_in=t.total_out=0,t.msg=null,t.istate.mode=7,t.istate.blocks.reset(t,null),0):-2}t.mode=0,t.method=0,t.was=[0],t.need=0,t.marker=0,t.wbits=0,t.inflateEnd=function(e){return t.blocks&&t.blocks.free(e),t.blocks=null,0},t.inflateInit=function(n,i){return n.msg=null,t.blocks=null,i<8||i>15?(t.inflateEnd(n),-2):(t.wbits=i,n.istate.blocks=new st(n,1<<i),e(n),0)},t.inflate=function(t,e){let n,i;if(!t||!t.istate||!t.next_in)return -2;const a=t.istate;for(e=4==e?-5:0,n=-5;;)switch(a.mode){case 0:if(0===t.avail_in)return n;if(n=e,t.avail_in--,t.total_in++,8!=(15&(a.method=t.read_byte(t.next_in_index++)))){a.mode=13,t.msg="unknown compression method",a.marker=5;break}if(8+(a.method>>4)>a.wbits){a.mode=13,t.msg="invalid window size",a.marker=5;break}a.mode=1;case 1:if(0===t.avail_in)return n;if(n=e,t.avail_in--,t.total_in++,i=255&t.read_byte(t.next_in_index++),((a.method<<8)+i)%31!=0){a.mode=13,t.msg="incorrect header check",a.marker=5;break}if(0==(32&i)){a.mode=7;break}a.mode=2;case 2:if(0===t.avail_in)return n;n=e,t.avail_in--,t.total_in++,a.need=(255&t.read_byte(t.next_in_index++))<<24&4278190080,a.mode=3;case 3:if(0===t.avail_in)return n;n=e,t.avail_in--,t.total_in++,a.need+=(255&t.read_byte(t.next_in_index++))<<16&16711680,a.mode=4;case 4:if(0===t.avail_in)return n;n=e,t.avail_in--,t.total_in++,a.need+=(255&t.read_byte(t.next_in_index++))<<8&65280,a.mode=5;case 5:return 0===t.avail_in?n:(n=e,t.avail_in--,t.total_in++,a.need+=255&t.read_byte(t.next_in_index++),a.mode=6,2);case 6:return a.mode=13,t.msg="need dictionary",a.marker=0,-2;case 7:if(n=a.blocks.proc(t,n),-3==n){a.mode=13,a.marker=0;break}if(0==n&&(n=e),1!=n)return n;n=e,a.blocks.reset(t,a.was),a.mode=12;case 12:return 1;case 13:return -3;default:return -2}},t.inflateSetDictionary=function(t,e,n){let i=0,a=n;if(!t||!t.istate||6!=t.istate.mode)return -2;const r=t.istate;return a>=1<<r.wbits&&(a=(1<<r.wbits)-1,i=n-a),r.blocks.set_dictionary(e,i,a),r.mode=7,0},t.inflateSync=function(t){let n,i,a,r,s;if(!t||!t.istate)return -2;const l=t.istate;if(13!=l.mode&&(l.mode=13,l.marker=0),0===(n=t.avail_in))return -5;for(i=t.next_in_index,a=l.marker;0!==n&&a<4;)t.read_byte(i)==lt[a]?a++:a=0!==t.read_byte(i)?0:4-a,i++,n--;return t.total_in+=i-t.next_in_index,t.next_in_index=i,t.avail_in=n,l.marker=a,4!=a?-3:(r=t.total_in,s=t.total_out,e(t),t.total_in=r,t.total_out=s,l.mode=7,0)},t.inflateSyncPoint=function(t){return t&&t.istate&&t.istate.blocks?t.istate.blocks.sync_point():-2};}function _t(){}function dt(t){const e=new _t,n=t&&t.chunkSize?Math.floor(2*t.chunkSize):131072,i=new Uint8Array(n);let a=!1;e.inflateInit(),e.next_out=i,this.append=function(t,r){const s=[];let l,o,_=0,d=0,c=0;if(0!==t.length){e.next_in_index=0,e.next_in=t,e.avail_in=t.length;do{if(e.next_out_index=0,e.avail_out=n,0!==e.avail_in||a||(e.next_in_index=0,a=!0),l=e.inflate(0),a&&-5===l){if(0!==e.avail_in)throw new Error("inflating: bad input")}else if(0!==l&&1!==l)throw new Error("inflating: "+e.msg);if((a||1===l)&&e.avail_in===t.length)throw new Error("inflating: bad input");e.next_out_index&&(e.next_out_index===n?s.push(new Uint8Array(i)):s.push(i.slice(0,e.next_out_index))),c+=e.next_out_index,r&&e.next_in_index>0&&e.next_in_index!=_&&(r(e.next_in_index),_=e.next_in_index);}while(e.avail_in>0||0===e.avail_out);return s.length>1?(o=new Uint8Array(c),s.forEach((function(t){o.set(t,d),d+=t.length;}))):o=s[0]||new Uint8Array(0),o}},this.flush=function(){e.inflateEnd();};}_t.prototype={inflateInit:function(t){const e=this;return e.istate=new ot,t||(t=15),e.istate.inflateInit(e,t)},inflate:function(t){const e=this;return e.istate?e.istate.inflate(e,t):-2},inflateEnd:function(){const t=this;if(!t.istate)return -2;const e=t.istate.inflateEnd(t);return t.istate=null,e},inflateSync:function(){const t=this;return t.istate?t.istate.inflateSync(t):-2},inflateSetDictionary:function(t,e){const n=this;return n.istate?n.istate.inflateSetDictionary(n,t,e):-2},read_byte:function(t){return this.next_in[t]},read_buf:function(t,e){return this.next_in.subarray(t,t+e)}},self.initCodec=()=>{self.Deflate=Q,self.Inflate=dt;};\n\n\t\t',
                n = URL.createObjectURL(new Blob([e], {type: "text/javascript"}));
            t({workerScripts: {inflate: [n], deflate: [n]}})
        }
    })(r), t.BlobReader = yt, t.BlobWriter = bt, t.Data64URIReader = class extends _t {
        constructor(t) {
            super(), this.dataURI = t;
            let e = t.length;
            for (; "=" == t.charAt(e - 1);) e--;
            this.dataStart = t.indexOf(",") + 1, this.size = Math.floor(.75 * (e - this.dataStart))
        }

        async readUint8Array(t, e) {
            const n = new Uint8Array(e), i = 4 * Math.floor(t / 3),
                r = atob(this.dataURI.substring(i + this.dataStart, 4 * Math.ceil((t + e) / 3) + this.dataStart)),
                a = t - 3 * Math.floor(i / 4);
            for (let t = a; t < a + e; t++) n[t - a] = r.charCodeAt(t);
            return n
        }
    }, t.Data64URIWriter = class extends gt {
        constructor(t) {
            super(), this.data = "data:" + (t || "") + ";base64,", this.pending = []
        }

        async writeUint8Array(t) {
            super.writeUint8Array(t);
            let e = 0, n = this.pending;
            const i = this.pending.length;
            for (this.pending = "", e = 0; e < 3 * Math.floor((i + t.length) / 3) - i; e++) n += String.fromCharCode(t[e]);
            for (; e < t.length; e++) this.pending += String.fromCharCode(t[e]);
            n.length > 2 ? this.data += btoa(n) : this.pending = n
        }

        getData() {
            return this.data + btoa(this.pending)
        }
    }, t.ERR_ABORT = st, t.ERR_BAD_FORMAT = Yt, t.ERR_CENTRAL_DIRECTORY_NOT_FOUND = ee, t.ERR_DUPLICATED_NAME = ve, t.ERR_ENCRYPTED = re, t.ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND = te, t.ERR_EOCDR_NOT_FOUND = $t, t.ERR_EOCDR_ZIP64_NOT_FOUND = Qt, t.ERR_EXTRAFIELD_ZIP64_NOT_FOUND = ie, t.ERR_HTTP_RANGE = ut, t.ERR_INVALID_COMMENT = Ae, t.ERR_INVALID_ENCRYPTION_STRENGTH = Se, t.ERR_INVALID_ENTRY_COMMENT = Ue, t.ERR_INVALID_ENTRY_NAME = Ee, t.ERR_INVALID_EXTRAFIELD_DATA = De, t.ERR_INVALID_EXTRAFIELD_TYPE = Re, t.ERR_INVALID_PASSWORD = w, t.ERR_INVALID_SIGNATURE = G, t.ERR_INVALID_VERSION = ze, t.ERR_LOCAL_FILE_HEADER_NOT_FOUND = ne, t.ERR_UNSUPPORTED_COMPRESSION = se, t.ERR_UNSUPPORTED_ENCRYPTION = ae, t.ERR_UNSUPPORTED_FORMAT = Te, t.HttpRangeReader = class extends Ft {
        constructor(t, e = {}) {
            e.useRangeHeader = !0, super(t, e)
        }
    }, t.HttpReader = Ft, t.Reader = _t, t.TextReader = class extends _t {
        constructor(t) {
            super(), this.blobReader = new yt(new Blob([t], {type: ft}))
        }

        async init() {
            super.init(), this.blobReader.init(), this.size = this.blobReader.size
        }

        async readUint8Array(t, e) {
            return this.blobReader.readUint8Array(t, e)
        }
    }, t.TextWriter = class extends gt {
        constructor(t) {
            super(), this.encoding = t, this.blob = new Blob([], {type: ft})
        }

        async writeUint8Array(t) {
            super.writeUint8Array(t), this.blob = new Blob([this.blob, t.buffer], {type: ft})
        }

        getData() {
            if (this.blob.text) return this.blob.text();
            {
                const t = new FileReader;
                return new Promise(((e, n) => {
                    t.onload = t => e(t.target.result), t.onerror = () => n(t.error), t.readAsText(this.blob, this.encoding)
                }))
            }
        }
    }, t.Uint8ArrayReader = class extends _t {
        constructor(t) {
            super(), this.array = t, this.size = t.length
        }

        async readUint8Array(t, e) {
            return this.array.slice(t, t + e)
        }
    }, t.Uint8ArrayWriter = class extends gt {
        constructor() {
            super(), this.array = new Uint8Array(0)
        }

        async writeUint8Array(t) {
            super.writeUint8Array(t);
            const e = this.array;
            this.array = new Uint8Array(e.length + t.length), this.array.set(e), this.array.set(t, e.length)
        }

        getData() {
            return this.array
        }
    }, t.Writer = gt, t.ZipReader = class {
        constructor(t, e = {}) {
            Object.assign(this, {reader: t, options: e, config: i()})
        }

        async getEntries(t = {}) {
            const e = this, n = e.reader;
            if (n.initialized || await n.init(), n.size < 22) throw new Error(Yt);
            const i = await async function (t, e, n, i, r) {
                const a = new Uint8Array(4);
                !function (t, e, n) {
                    t.setUint32(e, n, !0)
                }(xe(a), 0, e);
                const s = i + r;
                return await o(i) || await o(Math.min(s, n));

                async function o(e) {
                    const r = n - e, s = await ke(t, r, e);
                    for (let t = s.length - i; t >= 0; t--) if (s[t] == a[0] && s[t + 1] == a[1] && s[t + 2] == a[2] && s[t + 3] == a[3]) return {
                        offset: r + t,
                        buffer: s.slice(t, t + i).buffer
                    }
                }
            }(n, Lt, n.size, 22, 1048560);
            if (!i) throw new Error($t);
            const r = xe(i);
            let a = be(r, 12), s = be(r, 16), o = ye(r, 8), l = 0;
            if (s == It || a == It || o == Bt) {
                const t = xe(await ke(n, i.offset - 20, 20));
                if (be(t, 0) != Ht) throw new Error(Qt);
                s = me(t, 8);
                let e = await ke(n, s, 56), r = xe(e);
                const c = i.offset - 20 - 56;
                if (be(r, 0) != Ot && s != c) {
                    const t = s;
                    s = c, l = s - t, e = await ke(n, s, 56), r = xe(e)
                }
                if (be(r, 0) != Ot) throw new Error(te);
                o = me(r, 32), a = me(r, 40), s -= a
            }
            if (s < 0 || s >= n.size) throw new Error(Yt);
            let c = 0, d = await ke(n, s, a), u = xe(d);
            if (a) {
                const t = i.offset - a;
                if (be(u, c) != Wt && s != t) {
                    const e = s;
                    s = t, l = s - e, d = await ke(n, s, a), u = xe(d)
                }
            }
            if (s < 0 || s >= n.size) throw new Error(Yt);
            const f = [];
            for (let i = 0; i < o; i++) {
                const r = new de(n, e.config, e.options);
                if (be(u, c) != Wt) throw new Error(ee);
                ue(r, u, c + 6);
                const a = Boolean(r.bitFlag.languageEncodingFlag), s = c + 46, h = s + r.filenameLength,
                    p = h + r.extraFieldLength, w = ye(u, c + 4), _ = 0 == (0 & w);
                Object.assign(r, {
                    versionMadeBy: w,
                    msDosCompatible: _,
                    compressedSize: 0,
                    uncompressedSize: 0,
                    commentLength: ye(u, c + 32),
                    directory: _ && 16 == (16 & ge(u, c + 38)),
                    offset: be(u, c + 42) + l,
                    internalFileAttribute: be(u, c + 34),
                    externalFileAttribute: be(u, c + 38),
                    rawFilename: d.subarray(s, h),
                    filenameUTF8: a,
                    commentUTF8: a,
                    rawExtraField: d.subarray(h, p)
                });
                const g = p + r.commentLength;
                r.rawComment = d.subarray(p, g);
                const y = pe(e, t, "filenameEncoding"),
                    b = pe(e, t, "commentEncoding"), [m, x] = await Promise.all([Kt(r.rawFilename, r.filenameUTF8 ? oe : y || le), Kt(r.rawComment, r.commentUTF8 ? oe : b || le)]);
                r.filename = m, r.comment = x, !r.directory && r.filename.endsWith(Vt) && (r.directory = !0), await fe(r, r, u, c + 6);
                const k = new Jt(r);
                if (k.getData = (t, e) => r.getData(t, k, e), f.push(k), c = g, t.onprogress) try {
                    t.onprogress(i + 1, o, new Jt(r))
                } catch (t) {
                }
            }
            return f
        }

        async close() {
        }
    }, t.ZipWriter = class {
        constructor(t, e = {}) {
            Object.assign(this, {
                writer: t,
                options: e,
                config: i(),
                files: new Map,
                offset: t.size,
                pendingCompressedSize: 0,
                pendingEntries: []
            })
        }

        async add(t = "", e, n = {}) {
            const i = this;
            if (!(Be < i.config.maxWorkers)) return new Promise(((r, a) => i.pendingEntries.push({
                name: t,
                reader: e,
                options: n,
                resolve: r,
                reject: a
            })));
            Be++;
            try {
                return await async function (t, e, n, i) {
                    e = e.trim(), i.directory && !e.endsWith(Vt) ? e += Vt : i.directory = e.endsWith(Vt);
                    if (t.files.has(e)) throw new Error(ve);
                    const r = l(e);
                    if (r.length > Bt) throw new Error(Ee);
                    const a = i.comment || "", s = l(a);
                    if (s.length > Bt) throw new Error(Ue);
                    const o = t.options.version || i.version || 0;
                    if (o > Bt) throw new Error(ze);
                    const c = t.options.versionMadeBy || i.versionMadeBy || 20;
                    if (c > Bt) throw new Error(ze);
                    const d = We(t, i, "lastModDate") || new Date, u = We(t, i, "lastAccessDate"),
                        f = We(t, i, "creationDate"), h = We(t, i, "password"), p = We(t, i, "encryptionStrength") || 3,
                        w = We(t, i, "zipCrypto");
                    if (void 0 !== h && void 0 !== p && (p < 1 || p > 3)) throw new Error(Se);
                    let _ = new Uint8Array(0);
                    const g = i.extraField;
                    if (g) {
                        let t = 0, e = 0;
                        g.forEach((e => t += 4 + e.length)), _ = new Uint8Array(t), g.forEach(((t, n) => {
                            if (n > Bt) throw new Error(Re);
                            if (t.length > Bt) throw new Error(De);
                            Ne(_, new Uint16Array([n]), e), Ne(_, new Uint16Array([t.length]), e + 2), Ne(_, t, e + 4), e += 4 + t.length
                        }))
                    }
                    let y = We(t, i, "extendedTimestamp");
                    void 0 === y && (y = !0);
                    let b = 0, m = We(t, i, "keepOrder");
                    void 0 === m && (m = !0);
                    let x = 0, k = We(t, i, "msDosCompatible");
                    void 0 === k && (k = !0);
                    const v = We(t, i, "internalFileAttribute") || 0, A = We(t, i, "externalFileAttribute") || 0;
                    n && (n.initialized || await n.init(), x = n.size, b = function (t) {
                        return t + 5 * (Math.floor(t / 16383) + 1)
                    }(x));
                    let U = i.zip64 || t.options.zip64 || !1;
                    if (t.offset + t.pendingCompressedSize >= It || x >= It || b >= It) {
                        if (!1 === i.zip64 || !1 === t.options.zip64 || !m) throw new Error(Te);
                        U = !0
                    }
                    t.pendingCompressedSize += b, await Promise.resolve();
                    const E = We(t, i, "level"), z = We(t, i, "useWebWorkers"), S = We(t, i, "bufferedWrite");
                    let R = We(t, i, "dataDescriptor"), D = We(t, i, "dataDescriptorSignature");
                    const T = We(t, i, "signal");
                    void 0 === R && (R = !0);
                    R && void 0 === D && (D = !0);
                    const F = await async function (t, e, n, i) {
                        const r = t.files, a = t.writer, s = Array.from(r.values()).pop();
                        let o, l, c, d = {};
                        r.set(e, d);
                        try {
                            let u, f, h;
                            if (i.keepOrder && (u = s && s.lock), d.lock = h = new Promise((t => c = t)), i.bufferedWrite || t.lockWrite || !i.dataDescriptor ? (f = new bt, f.init(), o = !0) : (t.lockWrite = new Promise((t => l = t)), a.initialized || await a.init(), f = a), d = await async function (t, e, n, i) {
                                const {
                                    rawFilename: r,
                                    lastAccessDate: a,
                                    creationDate: s,
                                    password: o,
                                    level: l,
                                    zip64: c,
                                    zipCrypto: d,
                                    dataDescriptor: u,
                                    dataDescriptorSignature: f,
                                    directory: h,
                                    version: p,
                                    versionMadeBy: w,
                                    rawComment: _,
                                    rawExtraField: g,
                                    useWebWorkers: y,
                                    onprogress: b,
                                    signal: m,
                                    encryptionStrength: x,
                                    extendedTimestamp: k,
                                    msDosCompatible: v,
                                    internalFileAttribute: A,
                                    externalFileAttribute: U
                                } = i, E = Boolean(o && o.length), z = 0 !== l && !h;
                                let S, R, D;
                                if (E && !d) {
                                    S = new Uint8Array(Fe.length + 2);
                                    const t = je(S);
                                    Oe(t, 0, Pt), Ne(S, Fe, 2), Le(t, 8, x)
                                } else S = new Uint8Array(0);
                                if (k) {
                                    D = new Uint8Array(9 + (a ? 4 : 0) + (s ? 4 : 0));
                                    const t = je(D);
                                    Oe(t, 0, Nt), Oe(t, 2, D.length - 4);
                                    Le(t, 4, 1 + (a ? 2 : 0) + (s ? 4 : 0)), He(t, 5, Math.floor(i.lastModDate.getTime() / 1e3)), a && He(t, 9, Math.floor(a.getTime() / 1e3)), s && He(t, 13, Math.floor(s.getTime() / 1e3));
                                    try {
                                        R = new Uint8Array(36);
                                        const t = je(R), e = Me(i.lastModDate);
                                        Oe(t, 0, 10), Oe(t, 2, 32), Oe(t, 8, 1), Oe(t, 10, 24), Pe(t, 12, e), Pe(t, 20, Me(a) || e), Pe(t, 28, Me(s) || e)
                                    } catch (t) {
                                        R = new Uint8Array(0)
                                    }
                                } else R = D = new Uint8Array(0);
                                const T = {
                                    version: p || 20,
                                    versionMadeBy: w,
                                    zip64: c,
                                    directory: Boolean(h),
                                    filenameUTF8: !0,
                                    rawFilename: r,
                                    commentUTF8: !0,
                                    rawComment: _,
                                    rawExtraFieldZip64: c ? new Uint8Array(28) : new Uint8Array(0),
                                    rawExtraFieldExtendedTimestamp: D,
                                    rawExtraFieldNTFS: R,
                                    rawExtraFieldAES: S,
                                    rawExtraField: g,
                                    extendedTimestamp: k,
                                    msDosCompatible: v,
                                    internalFileAttribute: A,
                                    externalFileAttribute: U
                                };
                                let F = T.uncompressedSize = 0, I = jt;
                                u && (I |= 8);
                                let B = 0;
                                z && (B = 8);
                                c && (T.version = T.version > 45 ? T.version : 45);
                                E && (I |= 1, d || (T.version = T.version > 51 ? T.version : 51, B = 99, z && (T.rawExtraFieldAES[9] = 8)));
                                T.compressionMethod = B;
                                const C = T.headerArray = new Uint8Array(26), M = je(C);
                                Oe(M, 0, T.version), Oe(M, 2, I), Oe(M, 4, B);
                                const W = new Uint32Array(1), L = je(W);
                                let O;
                                O = i.lastModDate < qt ? qt : i.lastModDate > Zt ? Zt : i.lastModDate;
                                Oe(L, 0, (O.getHours() << 6 | O.getMinutes()) << 5 | O.getSeconds() / 2), Oe(L, 2, (O.getFullYear() - 1980 << 4 | O.getMonth() + 1) << 5 | O.getDate());
                                const H = W[0];
                                He(M, 6, H), Oe(M, 22, r.length);
                                const P = S.length + D.length + R.length + T.rawExtraField.length;
                                Oe(M, 24, P);
                                const N = new Uint8Array(30 + r.length + P);
                                let j;
                                He(je(N), 0, Ct), Ne(N, C, 4), Ne(N, r, 30), Ne(N, S, 30 + r.length), Ne(N, D, 30 + r.length + S.length), Ne(N, R, 30 + r.length + S.length + D.length), Ne(N, T.rawExtraField, 30 + r.length + S.length + D.length + R.length);
                                let V = 0;
                                if (t) {
                                    F = T.uncompressedSize = t.size;
                                    const i = await rt(n.Deflate, {
                                        codecType: Z,
                                        level: l,
                                        password: o,
                                        encryptionStrength: x,
                                        zipCrypto: E && d,
                                        passwordVerification: E && d && H >> 8 & 255,
                                        signed: !0,
                                        compressed: z,
                                        encrypted: E,
                                        useWebWorkers: y
                                    }, n);
                                    await e.writeUint8Array(N), T.dataWritten = !0, j = await ot(i, t, e, 0, F, n, {
                                        onprogress: b,
                                        signal: m
                                    }), V = j.length
                                } else await e.writeUint8Array(N), T.dataWritten = !0;
                                let q, G = new Uint8Array(0), K = 0;
                                u && (G = new Uint8Array(c ? f ? 24 : 20 : f ? 16 : 12), q = je(G), f && (K = 4, He(q, 0, Mt)));
                                if (t) {
                                    const t = j.signature;
                                    if (E && !d || void 0 === t || (He(M, 10, t), T.signature = t, u && He(q, K, t)), c) {
                                        const t = je(T.rawExtraFieldZip64);
                                        Oe(t, 0, 1), Oe(t, 2, 24), He(M, 14, It), Pe(t, 12, BigInt(V)), He(M, 18, It), Pe(t, 4, BigInt(F)), u && (Pe(q, K + 4, BigInt(V)), Pe(q, K + 12, BigInt(F)))
                                    } else He(M, 14, V), He(M, 18, F), u && (He(q, K + 4, V), He(q, K + 8, F))
                                }
                                u && await e.writeUint8Array(G);
                                const X = N.length + V + G.length;
                                return Object.assign(T, {
                                    compressedSize: V,
                                    lastModDate: O,
                                    rawLastModDate: H,
                                    creationDate: s,
                                    lastAccessDate: a,
                                    encrypted: E,
                                    length: X
                                }), T
                            }(n, f, t.config, i), d.lock = h, r.set(e, d), d.filename = e, o) {
                                let e = 0;
                                const n = f.getData();
                                let s;
                                await Promise.all([t.lockWrite, u]);
                                do {
                                    s = Array.from(r.values()).find((t => t.writingBufferedData)), s && await s.lock
                                } while (s && s.lock);
                                if (d.writingBufferedData = !0, !i.dataDescriptor) {
                                    const t = 26, r = await Ce(n, 0, t), s = new DataView(r);
                                    d.encrypted && !i.zipCrypto || He(s, 14, d.signature), d.zip64 ? (He(s, 18, It), He(s, 22, It)) : (He(s, 18, d.compressedSize), He(s, 22, d.uncompressedSize)), await a.writeUint8Array(new Uint8Array(r)), e = t
                                }
                                await async function (t, e, n = 0) {
                                    const i = 536870912;

                                    async function r() {
                                        if (n < e.size) {
                                            const a = await Ce(e, n, n + i);
                                            await t.writeUint8Array(new Uint8Array(a)), n += i, await r()
                                        }
                                    }

                                    await r()
                                }(a, n, e), delete d.writingBufferedData
                            }
                            if (d.offset = t.offset, d.zip64) {
                                Pe(je(d.rawExtraFieldZip64), 20, BigInt(d.offset))
                            } else if (d.offset >= It) throw new Error(Te);
                            return t.offset += d.length, d
                        } catch (n) {
                            throw(o && d.writingBufferedData || !o && d.dataWritten) && (n.corruptedEntry = t.hasCorruptedEntries = !0, d.uncompressedSize && (t.offset += d.uncompressedSize)), r.delete(e), n
                        } finally {
                            c(), l && l()
                        }
                    }(t, e, n, Object.assign({}, i, {
                        rawFilename: r,
                        rawComment: s,
                        version: o,
                        versionMadeBy: c,
                        lastModDate: d,
                        lastAccessDate: u,
                        creationDate: f,
                        rawExtraField: _,
                        zip64: U,
                        password: h,
                        level: E,
                        useWebWorkers: z,
                        encryptionStrength: p,
                        extendedTimestamp: y,
                        zipCrypto: w,
                        bufferedWrite: S,
                        keepOrder: m,
                        dataDescriptor: R,
                        dataDescriptorSignature: D,
                        signal: T,
                        msDosCompatible: k,
                        internalFileAttribute: v,
                        externalFileAttribute: A
                    }));
                    b && (t.pendingCompressedSize -= b);
                    return Object.assign(F, {name: e, comment: a, extraField: g}), new Jt(F)
                }(i, t, e, n)
            } finally {
                Be--;
                const t = i.pendingEntries.shift();
                t && i.add(t.name, t.reader, t.options).then(t.resolve).catch(t.reject)
            }
        }

        async close(t = new Uint8Array(0), e = {}) {
            return await async function (t, e, n) {
                const i = t.writer, r = t.files;
                let a = 0, s = 0, o = t.offset, l = r.size;
                for (const [, t] of r) s += 46 + t.rawFilename.length + t.rawComment.length + t.rawExtraFieldZip64.length + t.rawExtraFieldAES.length + t.rawExtraFieldExtendedTimestamp.length + t.rawExtraFieldNTFS.length + t.rawExtraField.length;
                let c = n.zip64 || t.options.zip64 || !1;
                if (o >= It || s >= It || l >= Bt) {
                    if (!1 === n.zip64 || !1 === t.options.zip64) throw new Error(Te);
                    c = !0
                }
                const d = new Uint8Array(s + (c ? 98 : 22)), u = je(d);
                if (e && e.length) {
                    if (!(e.length <= Bt)) throw new Error(Ae);
                    Oe(u, a + 20, e.length)
                }
                for (const [t, e] of Array.from(r.values()).entries()) {
                    const {
                        rawFilename: i,
                        rawExtraFieldZip64: s,
                        rawExtraFieldAES: o,
                        rawExtraField: l,
                        rawComment: c,
                        versionMadeBy: f,
                        headerArray: h,
                        directory: p,
                        zip64: w,
                        msDosCompatible: _,
                        internalFileAttribute: g,
                        externalFileAttribute: y
                    } = e;
                    let b, m;
                    if (e.extendedTimestamp) {
                        m = e.rawExtraFieldNTFS, b = new Uint8Array(9);
                        const t = je(b);
                        Oe(t, 0, Nt), Oe(t, 2, b.length - 4), Le(t, 4, 1), He(t, 5, Math.floor(e.lastModDate.getTime() / 1e3))
                    } else m = b = new Uint8Array(0);
                    const x = s.length + o.length + b.length + m.length + l.length;
                    if (He(u, a, Wt), Oe(u, a + 4, f), Ne(d, h, a + 6), Oe(u, a + 30, x), Oe(u, a + 32, c.length), He(u, a + 34, g), y ? He(u, a + 38, y) : p && _ && Le(u, a + 38, 16), He(u, a + 42, w ? It : e.offset), Ne(d, i, a + 46), Ne(d, s, a + 46 + i.length), Ne(d, o, a + 46 + i.length + s.length), Ne(d, b, a + 46 + i.length + s.length + o.length), Ne(d, m, a + 46 + i.length + s.length + o.length + b.length), Ne(d, l, a + 46 + i.length + s.length + o.length + b.length + m.length), Ne(d, c, a + 46 + i.length + x), a += 46 + i.length + x + c.length, n.onprogress) try {
                        n.onprogress(t + 1, r.size, new Jt(e))
                    } catch (t) {
                    }
                }
                c && (He(u, a, Ot), Pe(u, a + 4, BigInt(44)), Oe(u, a + 12, 45), Oe(u, a + 14, 45), Pe(u, a + 24, BigInt(l)), Pe(u, a + 32, BigInt(l)), Pe(u, a + 40, BigInt(s)), Pe(u, a + 48, BigInt(o)), He(u, a + 56, Ht), Pe(u, a + 64, BigInt(o) + BigInt(s)), He(u, a + 72, 1), l = Bt, o = It, s = It, a += 76);
                He(u, a, Lt), Oe(u, a + 8, l), Oe(u, a + 10, l), He(u, a + 12, s), He(u, a + 16, o), await i.writeUint8Array(d), e && e.length && await i.writeUint8Array(e)
            }(this, t, e), this.writer.getData()
        }
    }, t.configure = r, t.getMimeType = function () {
        return "application/octet-stream"
    }, t.initShimAsyncCodec = (t, e = {}, n) => ({
        Deflate: a(t.Deflate, e.deflate, n),
        Inflate: a(t.Inflate, e.inflate, n)
    }), t.terminateWorkers = function () {
        nt.forEach((t => {
            at(t), t.terminate()
        }))
    }, Object.defineProperty(t, "__esModule", {value: !0})
}));
